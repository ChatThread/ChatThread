export const CATEGERY_DATA = 
{
    "agents": {
        "Agent": {
            "template": {
                "_type": "Component",
                "memory": {
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "memory",
                    "value": "",
                    "display_name": "External Memory",
                    "advanced": true,
                    "input_types": [
                        "Memory"
                    ],
                    "dynamic": false,
                    "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "tools": {
                    "trace_as_metadata": true,
                    "list": true,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "tools",
                    "value": "",
                    "display_name": "Tools",
                    "advanced": false,
                    "input_types": [
                        "Tool"
                    ],
                    "dynamic": false,
                    "info": "These are the tools that the agent can use to help with tasks.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "add_current_date_tool": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "add_current_date_tool",
                    "value": true,
                    "display_name": "Current Date",
                    "advanced": true,
                    "dynamic": false,
                    "info": "If true, will add a tool to the agent that returns the current date.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "agent_description": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "agent_description",
                    "value": "A helpful assistant with access to the following tools:",
                    "display_name": "Agent Description [Deprecated]",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "agent_llm": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "Azure OpenAI",
                        "OpenAI",
                        "Custom"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "agent_llm",
                    "value": "OpenAI",
                    "display_name": "Model Provider",
                    "advanced": false,
                    "input_types": [],
                    "dynamic": false,
                    "info": "The provider of the language model that the agent will use to generate responses.",
                    "real_time_refresh": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "api_key": {
                    "load_from_db": false,
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "api_key",
                    "value": "",
                    "display_name": "OpenAI API Key",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The OpenAI API Key to use for the OpenAI model.",
                    "title_case": false,
                    "password": true,
                    "type": "str",
                    "_input_type": "SecretStrInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langchain_core.tools import StructuredTool\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.base.agents.events import ExceptionWithMessageError\nfrom langflow.base.models.model_input_constants import (\n    ALL_PROVIDER_FIELDS,\n    MODEL_DYNAMIC_UPDATE_FIELDS,\n    MODEL_PROVIDERS_DICT,\n)\nfrom langflow.base.models.model_utils import get_model_name\nfrom langflow.components.agents.current_date import CurrentDateComponent\nfrom langflow.components.agents.memory import MemoryComponent\nfrom langflow.components.agents.tool_calling import ToolCallingAgentComponent\nfrom langflow.custom.custom_component.component import _get_component_toolkit\nfrom langflow.custom.utils import update_component_build_config\nfrom langflow.field_typing import Tool\nfrom langflow.io import BoolInput, DropdownInput, MultilineInput, Output\nfrom langflow.logging import logger\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.schema.message import Message\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    inputs = [\n        DropdownInput(\n            name=\"agent_llm\",\n            display_name=\"Model Provider\",\n            info=\"The provider of the language model that the agent will use to generate responses.\",\n            options=[*sorted(MODEL_PROVIDERS_DICT.keys()), \"Custom\"],\n            value=\"OpenAI\",\n            real_time_refresh=True,\n            input_types=[],\n        ),\n        *MODEL_PROVIDERS_DICT[\"OpenAI\"][\"inputs\"],\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        *LCToolsAgentComponent._base_inputs,\n        *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [Output(name=\"response\", display_name=\"Response\", method=\"message_response\")]\n\n    async def message_response(self) -> Message:\n        try:\n            # Get LLM model and validate\n            llm_model, display_name = self.get_llm()\n            if llm_model is None:\n                msg = \"No language model selected. Please choose a model to proceed.\"\n                raise ValueError(msg)\n            self.model_name = get_model_name(llm_model, display_name=display_name)\n\n            # Get memory data\n            self.chat_history = await self.get_memory_data()\n\n            # Add current date tool if enabled\n            if self.add_current_date_tool:\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\n                    self.tools = []\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n                if not isinstance(current_date_tool, StructuredTool):\n                    msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                    raise TypeError(msg)\n                self.tools.append(current_date_tool)\n\n            # Validate tools\n            if not self.tools:\n                msg = \"Tools are required to run the agent. Please add at least one tool.\"\n                raise ValueError(msg)\n\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools,\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            return await self.run_agent(agent)\n\n        except (ValueError, TypeError, KeyError) as e:\n            logger.error(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            logger.error(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Unexpected error: {e!s}\")\n            raise\n\n    async def get_memory_data(self):\n        memory_kwargs = {\n            component_input.name: getattr(self, f\"{component_input.name}\") for component_input in self.memory_inputs\n        }\n        # filter out empty values\n        memory_kwargs = {k: v for k, v in memory_kwargs.items() if v}\n\n        return await MemoryComponent(**self.get_base_args()).set(**memory_kwargs).retrieve_messages()\n\n    def get_llm(self):\n        if not isinstance(self.agent_llm, str):\n            return self.agent_llm, None\n\n        try:\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if not provider_info:\n                msg = f\"Invalid model provider: {self.agent_llm}\"\n                raise ValueError(msg)\n\n            component_class = provider_info.get(\"component_class\")\n            display_name = component_class.display_name\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\", \"\")\n\n            return self._build_llm_model(component_class, inputs, prefix), display_name\n\n        except Exception as e:\n            logger.error(f\"Error building {self.agent_llm} language model: {e!s}\")\n            msg = f\"Failed to initialize language model: {e!s}\"\n            raise ValueError(msg) from e\n\n    def _build_llm_model(self, component, inputs, prefix=\"\"):\n        model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs}\n        return component.set(**model_kwargs).build_model()\n\n    def set_component_params(self, component):\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n        if provider_info:\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\")\n            model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs}\n\n            return component.set(**model_kwargs)\n        return component\n\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\n        \"\"\"Delete specified fields from build_config.\"\"\"\n        for field in fields:\n            build_config.pop(field, None)\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\n    ) -> dotdict:\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        # Existing logic for updating build_config\n        if field_name in (\"agent_llm\",):\n            build_config[\"agent_llm\"][\"value\"] = field_value\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call the component class's update_build_config method\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\n                provider: (\n                    MODEL_PROVIDERS_DICT[provider][\"fields\"],\n                    [\n                        MODEL_PROVIDERS_DICT[other_provider][\"fields\"]\n                        for other_provider in MODEL_PROVIDERS_DICT\n                        if other_provider != provider\n                    ],\n                )\n                for provider in MODEL_PROVIDERS_DICT\n            }\n            if field_value in provider_configs:\n                fields_to_add, fields_to_delete = provider_configs[field_value]\n\n                # Delete fields from other providers\n                for fields in fields_to_delete:\n                    self.delete_fields(build_config, fields)\n\n                # Add provider-specific fields\n                if field_value == \"OpenAI\" and not any(field in build_config for field in fields_to_add):\n                    build_config.update(fields_to_add)\n                else:\n                    build_config.update(fields_to_add)\n                # Reset input types for agent_llm\n                build_config[\"agent_llm\"][\"input_types\"] = []\n            elif field_value == \"Custom\":\n                # Delete all provider fields\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\n                # Update with custom component\n                custom_component = DropdownInput(\n                    name=\"agent_llm\",\n                    display_name=\"Language Model\",\n                    options=[*sorted(MODEL_PROVIDERS_DICT.keys()), \"Custom\"],\n                    value=\"Custom\",\n                    real_time_refresh=True,\n                    input_types=[\"LanguageModel\"],\n                )\n                build_config.update({\"agent_llm\": custom_component.to_dict()})\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"agent_llm\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        if (\n            isinstance(self.agent_llm, str)\n            and self.agent_llm in MODEL_PROVIDERS_DICT\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\n        ):\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                component_class = self.set_component_params(component_class)\n                prefix = provider_info.get(\"prefix\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call each component class's update_build_config method\n                    # remove the prefix from the field_name\n                    if isinstance(field_name, str) and isinstance(prefix, str):\n                        field_name = field_name.replace(prefix, \"\")\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n\n    async def to_toolkit(self) -> list[Tool]:\n        component_toolkit = _get_component_toolkit()\n        tools_names = self._build_tools_names()\n        agent_description = self.get_tool_description()\n        # TODO: Agent Description Depreciated Feature to be removed\n        description = f\"{agent_description}{tools_names}\"\n        tools = component_toolkit(component=self).get_tools(\n            tool_name=self.get_tool_name(), tool_description=description, callbacks=self.get_langchain_callbacks()\n        )\n        if hasattr(self, \"tools_metadata\"):\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\n        return tools\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "handle_parsing_errors": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "handle_parsing_errors",
                    "value": true,
                    "display_name": "Handle Parse Errors",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Should the Agent fix errors when reading user input for better processing?",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "input_value": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "",
                    "display_name": "Input",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The input provided by the user for the agent to process.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "json_mode": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "json_mode",
                    "value": false,
                    "display_name": "JSON Mode",
                    "advanced": true,
                    "dynamic": false,
                    "info": "If True, it will output JSON regardless of passing a schema.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "max_iterations": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_iterations",
                    "value": 15,
                    "display_name": "Max Iterations",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "max_retries": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_retries",
                    "value": 5,
                    "display_name": "Max Retries",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The maximum number of retries to make when generating.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "max_tokens": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "range_spec": {
                        "step_type": "float",
                        "min": 0,
                        "max": 128000,
                        "step": 0.1
                    },
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_tokens",
                    "value": "",
                    "display_name": "Max Tokens",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "model_kwargs": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "model_kwargs",
                    "value": {},
                    "display_name": "Model Kwargs",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Additional keyword arguments to pass to the model.",
                    "title_case": false,
                    "type": "dict",
                    "_input_type": "DictInput"
                },
                "model_name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "model_name",
                    "value": "gpt-4o-mini",
                    "display_name": "Model Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "To see the model names, first choose a provider. Then, enter your API key and click the refresh button next to the model name.",
                    "real_time_refresh": false,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "n_messages": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "n_messages",
                    "value": 100,
                    "display_name": "Number of Messages",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Number of messages to retrieve.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "openai_api_base": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "openai_api_base",
                    "value": "",
                    "display_name": "OpenAI API Base",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "order": {
                    "tool_mode": true,
                    "trace_as_metadata": true,
                    "options": [
                        "Ascending",
                        "Descending"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "order",
                    "value": "Ascending",
                    "display_name": "Order",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Order of the messages.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "seed": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "seed",
                    "value": 1,
                    "display_name": "Seed",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The seed controls the reproducibility of the job.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "sender": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "Machine",
                        "User",
                        "Machine and User"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender",
                    "value": "Machine and User",
                    "display_name": "Sender Type",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Filter by sender type.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender_name": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender_name",
                    "value": "",
                    "display_name": "Sender Name",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Filter by sender name.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "session_id": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": "",
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "system_prompt": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "system_prompt",
                    "value": "You are a helpful assistant that can use tools to answer questions and perform tasks.",
                    "display_name": "Agent Instructions",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "temperature": {
                    "tool_mode": false,
                    "min_label": "",
                    "max_label": "",
                    "min_label_icon": "",
                    "max_label_icon": "",
                    "slider_buttons": false,
                    "slider_buttons_options": [],
                    "slider_input": false,
                    "range_spec": {
                        "step_type": "float",
                        "min": 0,
                        "max": 1,
                        "step": 0.01
                    },
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "temperature",
                    "value": 0.1,
                    "display_name": "Temperature",
                    "advanced": true,
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "slider",
                    "_input_type": "SliderInput"
                },
                "template": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "template",
                    "value": "{sender_name}: {text}",
                    "display_name": "Template",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "timeout": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "timeout",
                    "value": 700,
                    "display_name": "Timeout",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The timeout for requests to OpenAI completion API.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "verbose": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "verbose",
                    "value": true,
                    "display_name": "Verbose",
                    "advanced": true,
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                }
            },
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "icon": "bot",
            "base_classes": [
                "Message"
            ],
            "display_name": "Agent",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "response",
                    "display_name": "Response",
                    "method": "message_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "agent_llm",
                "max_tokens",
                "model_kwargs",
                "json_mode",
                "model_name",
                "openai_api_base",
                "api_key",
                "temperature",
                "seed",
                "max_retries",
                "timeout",
                "system_prompt",
                "tools",
                "input_value",
                "handle_parsing_errors",
                "verbose",
                "max_iterations",
                "agent_description",
                "memory",
                "sender",
                "sender_name",
                "n_messages",
                "session_id",
                "order",
                "template",
                "add_current_date_tool"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "CurrentDate": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from datetime import datetime\nfrom zoneinfo import ZoneInfo, available_timezones\n\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import DropdownInput, Output\nfrom langflow.schema.message import Message\n\n\nclass CurrentDateComponent(Component):\n    display_name = \"Current Date\"\n    description = \"Returns the current date and time in the selected timezone.\"\n    icon = \"clock\"\n    name = \"CurrentDate\"\n\n    inputs = [\n        DropdownInput(\n            name=\"timezone\",\n            display_name=\"Timezone\",\n            options=list(available_timezones()),\n            value=\"UTC\",\n            info=\"Select the timezone for the current date and time.\",\n            tool_mode=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Current Date\", name=\"current_date\", method=\"get_current_date\"),\n    ]\n\n    def get_current_date(self) -> Message:\n        try:\n            tz = ZoneInfo(self.timezone)\n            current_date = datetime.now(tz).strftime(\"%Y-%m-%d %H:%M:%S %Z\")\n            result = f\"Current date and time in {self.timezone}: {current_date}\"\n            self.status = result\n            return Message(text=result)\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error getting current date\")\n            error_message = f\"Error: {e}\"\n            self.status = error_message\n            return Message(text=error_message)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "timezone": {
                    "tool_mode": true,
                    "trace_as_metadata": true,
                    "options": [
                        "America/Catamarca",
                        "Brazil/East",
                        "Europe/Dublin",
                        "America/Dominica",
                        "Asia/Anadyr",
                        "Asia/Atyrau",
                        "Canada/Eastern",
                        "Pacific/Saipan",
                        "Pacific/Guadalcanal",
                        "America/Ensenada",
                        "Pacific/Pitcairn",
                        "Africa/Monrovia",
                        "America/Bahia",
                        "America/Ojinaga",
                        "Asia/Thimphu",
                        "Asia/Dubai",
                        "Europe/Warsaw",
                        "Etc/GMT+2",
                        "America/Panama",
                        "Etc/GMT-8",
                        "America/St_Barthelemy",
                        "Australia/Darwin",
                        "Iran",
                        "Indian/Cocos",
                        "Antarctica/McMurdo",
                        "America/Mexico_City",
                        "America/Juneau",
                        "America/Shiprock",
                        "Asia/Tokyo",
                        "Africa/Libreville",
                        "America/Swift_Current",
                        "Africa/El_Aaiun",
                        "Asia/Damascus",
                        "WET",
                        "Asia/Qyzylorda",
                        "Africa/Conakry",
                        "Asia/Harbin",
                        "America/Tijuana",
                        "Africa/Sao_Tome",
                        "Atlantic/St_Helena",
                        "US/Eastern",
                        "Antarctica/DumontDUrville",
                        "Indian/Chagos",
                        "America/Merida",
                        "America/Santarem",
                        "Africa/Accra",
                        "Asia/Novokuznetsk",
                        "Canada/Central",
                        "Pacific/Midway",
                        "Asia/Almaty",
                        "Pacific/Wake",
                        "Asia/Oral",
                        "Indian/Comoro",
                        "America/Rosario",
                        "EST",
                        "Australia/Adelaide",
                        "Asia/Kashgar",
                        "America/Kentucky/Louisville",
                        "America/Fortaleza",
                        "Europe/Monaco",
                        "Pacific/Port_Moresby",
                        "Asia/Vladivostok",
                        "Atlantic/Cape_Verde",
                        "Asia/Baghdad",
                        "Etc/GMT-5",
                        "Australia/Brisbane",
                        "Etc/GMT-10",
                        "Europe/Isle_of_Man",
                        "GMT+0",
                        "Asia/Gaza",
                        "Asia/Choibalsan",
                        "America/Atka",
                        "America/Inuvik",
                        "Etc/GMT-6",
                        "Africa/Windhoek",
                        "Canada/Mountain",
                        "America/Sao_Paulo",
                        "HST",
                        "GMT",
                        "America/Rio_Branco",
                        "America/Guadeloupe",
                        "America/Moncton",
                        "America/Grenada",
                        "America/Detroit",
                        "Asia/Colombo",
                        "Pacific/Norfolk",
                        "Factory",
                        "America/Porto_Acre",
                        "MST7MDT",
                        "Pacific/Funafuti",
                        "Australia/West",
                        "America/Lima",
                        "Etc/GMT+4",
                        "Etc/GMT-1",
                        "Africa/Brazzaville",
                        "Etc/GMT+8",
                        "Europe/Prague",
                        "Africa/Cairo",
                        "Asia/Pyongyang",
                        "Etc/GMT+5",
                        "Africa/Kampala",
                        "America/Glace_Bay",
                        "CET",
                        "America/Fort_Nelson",
                        "America/Araguaina",
                        "Africa/Harare",
                        "America/Asuncion",
                        "Australia/Queensland",
                        "America/Guayaquil",
                        "America/Havana",
                        "America/Rainy_River",
                        "Europe/Uzhgorod",
                        "Etc/GMT+12",
                        "Libya",
                        "Etc/GMT",
                        "Africa/Freetown",
                        "Atlantic/Jan_Mayen",
                        "America/Phoenix",
                        "Australia/Currie",
                        "EET",
                        "Africa/Bissau",
                        "Asia/Yerevan",
                        "Europe/Tirane",
                        "Pacific/Palau",
                        "Etc/GMT0",
                        "America/Edmonton",
                        "Asia/Karachi",
                        "Europe/Ulyanovsk",
                        "Mexico/General",
                        "Australia/LHI",
                        "US/Mountain",
                        "Africa/Kinshasa",
                        "Europe/Sofia",
                        "Europe/San_Marino",
                        "Asia/Aqtobe",
                        "America/Port_of_Spain",
                        "Hongkong",
                        "Europe/Ljubljana",
                        "America/Indiana/Indianapolis",
                        "Etc/GMT+9",
                        "Turkey",
                        "US/Indiana-Starke",
                        "America/Cuiaba",
                        "America/Knox_IN",
                        "Antarctica/Troll",
                        "Asia/Ho_Chi_Minh",
                        "America/Argentina/San_Luis",
                        "Etc/GMT-14",
                        "Europe/Riga",
                        "America/Indiana/Knox",
                        "Asia/Makassar",
                        "Kwajalein",
                        "Zulu",
                        "Asia/Macao",
                        "US/Michigan",
                        "America/Recife",
                        "US/Aleutian",
                        "America/Creston",
                        "W-SU",
                        "Europe/Sarajevo",
                        "America/Indiana/Petersburg",
                        "Asia/Dacca",
                        "UTC",
                        "Asia/Amman",
                        "Etc/GMT+6",
                        "Pacific/Noumea",
                        "CST6CDT",
                        "America/Atikokan",
                        "Indian/Mahe",
                        "Etc/GMT-2",
                        "ROK",
                        "Pacific/Bougainville",
                        "GMT-0",
                        "America/Montreal",
                        "Australia/NSW",
                        "America/Mendoza",
                        "Indian/Maldives",
                        "Africa/Mbabane",
                        "America/St_Johns",
                        "Australia/Lord_Howe",
                        "Etc/GMT-13",
                        "US/Central",
                        "America/Rankin_Inlet",
                        "Asia/Brunei",
                        "Pacific/Tahiti",
                        "America/Eirunepe",
                        "Europe/Zaporozhye",
                        "EST5EDT",
                        "Europe/Saratov",
                        "Antarctica/Davis",
                        "Asia/Barnaul",
                        "Europe/Madrid",
                        "Antarctica/Casey",
                        "Australia/North",
                        "Mexico/BajaSur",
                        "America/Punta_Arenas",
                        "Indian/Christmas",
                        "Europe/Bucharest",
                        "US/Hawaii",
                        "Etc/Universal",
                        "Europe/Astrakhan",
                        "Asia/Novosibirsk",
                        "Antarctica/South_Pole",
                        "America/El_Salvador",
                        "America/Dawson_Creek",
                        "America/Thule",
                        "PST8PDT",
                        "Pacific/Kosrae",
                        "America/Yellowknife",
                        "Asia/Pontianak",
                        "Atlantic/Madeira",
                        "Pacific/Galapagos",
                        "America/St_Thomas",
                        "Navajo",
                        "America/Anchorage",
                        "America/North_Dakota/Center",
                        "America/Costa_Rica",
                        "America/Anguilla",
                        "MET",
                        "Africa/Tunis",
                        "Pacific/Nauru",
                        "Asia/Famagusta",
                        "Africa/Lusaka",
                        "America/Montserrat",
                        "Pacific/Efate",
                        "America/Cayman",
                        "Pacific/Kanton",
                        "America/St_Vincent",
                        "America/Argentina/Buenos_Aires",
                        "US/Pacific",
                        "Asia/Vientiane",
                        "Asia/Jayapura",
                        "Asia/Omsk",
                        "Asia/Samarkand",
                        "Pacific/Ponape",
                        "Africa/Asmera",
                        "America/Argentina/San_Juan",
                        "Asia/Urumqi",
                        "America/Aruba",
                        "Asia/Krasnoyarsk",
                        "Europe/Kyiv",
                        "Atlantic/South_Georgia",
                        "Africa/Timbuktu",
                        "Pacific/Apia",
                        "America/Menominee",
                        "Antarctica/Vostok",
                        "America/Goose_Bay",
                        "Pacific/Yap",
                        "Asia/Magadan",
                        "America/Coyhaique",
                        "Pacific/Honolulu",
                        "America/Argentina/Salta",
                        "Africa/Abidjan",
                        "Europe/Berlin",
                        "Europe/Athens",
                        "Canada/Newfoundland",
                        "America/Mazatlan",
                        "Cuba",
                        "America/Adak",
                        "America/Los_Angeles",
                        "Pacific/Majuro",
                        "Etc/GMT-11",
                        "Europe/Mariehamn",
                        "America/Iqaluit",
                        "America/Nuuk",
                        "Pacific/Kiritimati",
                        "America/Nassau",
                        "Asia/Kuala_Lumpur",
                        "Egypt",
                        "Etc/GMT+7",
                        "Etc/GMT-4",
                        "Europe/Guernsey",
                        "NZ",
                        "US/Alaska",
                        "Japan",
                        "Africa/Mogadishu",
                        "Asia/Dhaka",
                        "Singapore",
                        "Europe/Malta",
                        "Asia/Saigon",
                        "Jamaica",
                        "America/Toronto",
                        "Asia/Manila",
                        "Europe/Minsk",
                        "Pacific/Auckland",
                        "Africa/Bangui",
                        "Africa/Porto-Novo",
                        "America/Cordoba",
                        "Europe/Kiev",
                        "Australia/Eucla",
                        "Australia/Sydney",
                        "Asia/Calcutta",
                        "America/Paramaribo",
                        "America/Chicago",
                        "Asia/Ulan_Bator",
                        "Europe/Copenhagen",
                        "Asia/Chita",
                        "Africa/Dakar",
                        "ROC",
                        "America/Metlakatla",
                        "Europe/Andorra",
                        "America/Santiago",
                        "Israel",
                        "Canada/Atlantic",
                        "Antarctica/Mawson",
                        "Mexico/BajaNorte",
                        "Europe/Vienna",
                        "Asia/Phnom_Penh",
                        "America/Cayenne",
                        "Africa/Bujumbura",
                        "Brazil/Acre",
                        "Pacific/Tongatapu",
                        "America/Port-au-Prince",
                        "America/Belize",
                        "America/Chihuahua",
                        "Europe/Volgograd",
                        "Asia/Katmandu",
                        "Pacific/Enderbury",
                        "America/Jamaica",
                        "America/Virgin",
                        "Africa/Gaborone",
                        "America/Nome",
                        "Asia/Muscat",
                        "Asia/Kuwait",
                        "America/Martinique",
                        "America/New_York",
                        "Pacific/Kwajalein",
                        "America/Resolute",
                        "America/Bogota",
                        "Asia/Hovd",
                        "Africa/Douala",
                        "Etc/Zulu",
                        "Etc/GMT-12",
                        "Asia/Chongqing",
                        "Europe/Zagreb",
                        "America/St_Lucia",
                        "Atlantic/Reykjavik",
                        "Asia/Bahrain",
                        "Africa/Ceuta",
                        "America/Santo_Domingo",
                        "Chile/Continental",
                        "America/Buenos_Aires",
                        "MST",
                        "Asia/Dushanbe",
                        "Canada/Saskatchewan",
                        "America/Fort_Wayne",
                        "Europe/Luxembourg",
                        "America/Indiana/Winamac",
                        "Asia/Dili",
                        "Europe/Gibraltar",
                        "Pacific/Marquesas",
                        "Atlantic/Faeroe",
                        "America/Argentina/Catamarca",
                        "Pacific/Chatham",
                        "US/Arizona",
                        "Africa/Ouagadougou",
                        "Indian/Mauritius",
                        "Europe/Brussels",
                        "Africa/Tripoli",
                        "Indian/Antananarivo",
                        "America/Marigot",
                        "Australia/Victoria",
                        "America/Coral_Harbour",
                        "America/Guyana",
                        "Pacific/Gambier",
                        "Indian/Kerguelen",
                        "Asia/Hebron",
                        "America/Argentina/Rio_Gallegos",
                        "Pacific/Chuuk",
                        "Etc/GMT+3",
                        "Asia/Yakutsk",
                        "Europe/Samara",
                        "Pacific/Pohnpei",
                        "America/Dawson",
                        "America/Miquelon",
                        "Asia/Beirut",
                        "Asia/Aqtau",
                        "Australia/Perth",
                        "America/Winnipeg",
                        "America/Noronha",
                        "America/Matamoros",
                        "Etc/GMT-9",
                        "Asia/Tbilisi",
                        "Pacific/Fakaofo",
                        "Poland",
                        "Africa/Maputo",
                        "Arctic/Longyearbyen",
                        "America/Pangnirtung",
                        "Pacific/Niue",
                        "Australia/South",
                        "Africa/Addis_Ababa",
                        "Atlantic/Azores",
                        "Pacific/Guam",
                        "America/Blanc-Sablon",
                        "US/Samoa",
                        "Asia/Ashkhabad",
                        "America/Caracas",
                        "America/Denver",
                        "Asia/Irkutsk",
                        "GB-Eire",
                        "Africa/Johannesburg",
                        "America/Argentina/La_Rioja",
                        "Etc/GMT+11",
                        "Asia/Yangon",
                        "Etc/UCT",
                        "UCT",
                        "Europe/Istanbul",
                        "Europe/Belgrade",
                        "Asia/Bangkok",
                        "America/Santa_Isabel",
                        "Indian/Reunion",
                        "Asia/Rangoon",
                        "America/Guatemala",
                        "America/Monterrey",
                        "America/Argentina/Ushuaia",
                        "Indian/Mayotte",
                        "America/Boa_Vista",
                        "America/Regina",
                        "Europe/Nicosia",
                        "America/North_Dakota/Beulah",
                        "America/Bahia_Banderas",
                        "Australia/Tasmania",
                        "Asia/Macau",
                        "US/East-Indiana",
                        "Asia/Tehran",
                        "Europe/Moscow",
                        "Asia/Ashgabat",
                        "Africa/Khartoum",
                        "America/Tegucigalpa",
                        "Canada/Pacific",
                        "Europe/Belfast",
                        "Asia/Tel_Aviv",
                        "Europe/Tallinn",
                        "Africa/Bamako",
                        "America/Indiana/Vincennes",
                        "America/Antigua",
                        "America/Managua",
                        "Europe/Lisbon",
                        "Africa/Algiers",
                        "America/St_Kitts",
                        "Asia/Tomsk",
                        "America/Nipigon",
                        "America/Campo_Grande",
                        "Iceland",
                        "NZ-CHAT",
                        "Australia/Melbourne",
                        "Africa/Nairobi",
                        "America/Boise",
                        "Africa/Nouakchott",
                        "Europe/Skopje",
                        "America/Lower_Princes",
                        "Europe/Vatican",
                        "America/Grand_Turk",
                        "Australia/Lindeman",
                        "localtime",
                        "Europe/Budapest",
                        "America/Argentina/Tucuman",
                        "Asia/Riyadh",
                        "America/Scoresbysund",
                        "America/La_Paz",
                        "Asia/Thimbu",
                        "Europe/Podgorica",
                        "Portugal",
                        "Asia/Baku",
                        "Asia/Kuching",
                        "Asia/Singapore",
                        "Africa/Kigali",
                        "Africa/Lubumbashi",
                        "Atlantic/Stanley",
                        "Europe/Chisinau",
                        "Europe/Oslo",
                        "Europe/Simferopol",
                        "Etc/GMT-0",
                        "Africa/Casablanca",
                        "America/Whitehorse",
                        "America/Indiana/Marengo",
                        "Asia/Bishkek",
                        "America/Belem",
                        "Europe/Helsinki",
                        "America/Manaus",
                        "Brazil/DeNoronha",
                        "Europe/Zurich",
                        "Pacific/Samoa",
                        "Asia/Khandyga",
                        "Antarctica/Syowa",
                        "Pacific/Wallis",
                        "Africa/Ndjamena",
                        "Europe/Bratislava",
                        "Asia/Jakarta",
                        "Africa/Juba",
                        "Australia/Hobart",
                        "Asia/Chungking",
                        "America/Thunder_Bay",
                        "America/Montevideo",
                        "Universal",
                        "America/Godthab",
                        "Etc/GMT-7",
                        "Asia/Ujung_Pandang",
                        "Atlantic/Faroe",
                        "Africa/Blantyre",
                        "Europe/London",
                        "Asia/Sakhalin",
                        "America/Barbados",
                        "Africa/Banjul",
                        "America/Puerto_Rico",
                        "Asia/Taipei",
                        "Australia/Canberra",
                        "America/Vancouver",
                        "Chile/EasterIsland",
                        "Africa/Lagos",
                        "Asia/Kolkata",
                        "Europe/Stockholm",
                        "Asia/Nicosia",
                        "Australia/Yancowinna",
                        "Eire",
                        "Canada/Yukon",
                        "Asia/Jerusalem",
                        "America/Danmarkshavn",
                        "Pacific/Rarotonga",
                        "Asia/Kathmandu",
                        "Asia/Kabul",
                        "Africa/Luanda",
                        "America/Cambridge_Bay",
                        "Europe/Rome",
                        "Australia/Broken_Hill",
                        "Asia/Qatar",
                        "Atlantic/Canary",
                        "America/Porto_Velho",
                        "Asia/Qostanay",
                        "Antarctica/Macquarie",
                        "Pacific/Easter",
                        "America/Argentina/Jujuy",
                        "Asia/Ust-Nera",
                        "Etc/Greenwich",
                        "Pacific/Johnston",
                        "Africa/Djibouti",
                        "Europe/Tiraspol",
                        "Antarctica/Palmer",
                        "America/Louisville",
                        "Africa/Maseru",
                        "Asia/Kamchatka",
                        "Etc/GMT+10",
                        "America/Cancun",
                        "America/Hermosillo",
                        "Asia/Aden",
                        "Pacific/Truk",
                        "America/Jujuy",
                        "GB",
                        "Europe/Kaliningrad",
                        "Europe/Amsterdam",
                        "Etc/GMT+0",
                        "Asia/Ulaanbaatar",
                        "Etc/GMT-3",
                        "America/North_Dakota/New_Salem",
                        "America/Sitka",
                        "Europe/Kirov",
                        "America/Argentina/Cordoba",
                        "Pacific/Tarawa",
                        "America/Halifax",
                        "Australia/ACT",
                        "America/Tortola",
                        "Atlantic/Bermuda",
                        "America/Indiana/Vevay",
                        "Asia/Srednekolymsk",
                        "America/Argentina/Mendoza",
                        "Africa/Dar_es_Salaam",
                        "Africa/Lome",
                        "Brazil/West",
                        "Europe/Paris",
                        "Europe/Busingen",
                        "America/Kentucky/Monticello",
                        "Etc/UTC",
                        "Europe/Vaduz",
                        "Greenwich",
                        "PRC",
                        "America/Ciudad_Juarez",
                        "Africa/Niamey",
                        "Asia/Tashkent",
                        "Europe/Jersey",
                        "America/Maceio",
                        "Africa/Asmara",
                        "Europe/Vilnius",
                        "America/Indiana/Tell_City",
                        "Asia/Shanghai",
                        "GMT0",
                        "Africa/Malabo",
                        "America/Argentina/ComodRivadavia",
                        "Pacific/Pago_Pago",
                        "Asia/Istanbul",
                        "Antarctica/Rothera",
                        "Asia/Hong_Kong",
                        "Asia/Seoul",
                        "Etc/GMT+1",
                        "Asia/Yekaterinburg",
                        "Pacific/Fiji",
                        "America/Kralendijk",
                        "America/Yakutat",
                        "America/Indianapolis",
                        "America/Curacao"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "timezone",
                    "value": "UTC",
                    "display_name": "Timezone",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Select the timezone for the current date and time.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                }
            },
            "description": "Returns the current date and time in the selected timezone.",
            "icon": "clock",
            "base_classes": [
                "Message"
            ],
            "display_name": "Current Date",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "current_date",
                    "display_name": "Current Date",
                    "method": "get_current_date",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "timezone"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "Memory": {
            "template": {
                "_type": "Component",
                "memory": {
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "memory",
                    "value": "",
                    "display_name": "External Memory",
                    "advanced": false,
                    "input_types": [
                        "Memory"
                    ],
                    "dynamic": false,
                    "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import aget_messages\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Message History\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"Memory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Message\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n    ]\n\n    async def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = await self.memory.aget_messages()\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = await aget_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    async def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, await self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "n_messages": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "n_messages",
                    "value": 100,
                    "display_name": "Number of Messages",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Number of messages to retrieve.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "order": {
                    "tool_mode": true,
                    "trace_as_metadata": true,
                    "options": [
                        "Ascending",
                        "Descending"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "order",
                    "value": "Ascending",
                    "display_name": "Order",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Order of the messages.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "Machine",
                        "User",
                        "Machine and User"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender",
                    "value": "Machine and User",
                    "display_name": "Sender Type",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Filter by sender type.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender_name": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender_name",
                    "value": "",
                    "display_name": "Sender Name",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Filter by sender name.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "session_id": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": "",
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "template": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "template",
                    "value": "{sender_name}: {text}",
                    "display_name": "Template",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                }
            },
            "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
            "icon": "message-square-more",
            "base_classes": [
                "Data",
                "Message"
            ],
            "display_name": "Message History",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "messages",
                    "display_name": "Data",
                    "method": "retrieve_messages",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "messages_text",
                    "display_name": "Message",
                    "method": "retrieve_messages_as_text",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "memory",
                "sender",
                "sender_name",
                "n_messages",
                "session_id",
                "order",
                "template"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "ToolCallingAgent": {
            "template": {
                "_type": "Component",
                "chat_history": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": true,
                    "list_add_label": "Add More",
                    "trace_as_input": true,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "chat_history",
                    "value": "",
                    "display_name": "Chat Memory",
                    "advanced": true,
                    "input_types": [
                        "Data"
                    ],
                    "dynamic": false,
                    "info": "This input stores the chat history, allowing the agent to remember previous conversations.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "DataInput"
                },
                "llm": {
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "llm",
                    "value": "",
                    "display_name": "Language Model",
                    "advanced": false,
                    "input_types": [
                        "LanguageModel"
                    ],
                    "dynamic": false,
                    "info": "Language model that the agent utilizes to perform tasks effectively.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "tools": {
                    "trace_as_metadata": true,
                    "list": true,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "tools",
                    "value": "",
                    "display_name": "Tools",
                    "advanced": false,
                    "input_types": [
                        "Tool"
                    ],
                    "dynamic": false,
                    "info": "These are the tools that the agent can use to help with tasks.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "agent_description": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "agent_description",
                    "value": "A helpful assistant with access to the following tools:",
                    "display_name": "Agent Description [Deprecated]",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langchain.agents import create_tool_calling_agent\nfrom langchain_core.prompts import ChatPromptTemplate\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.custom.custom_component.component import _get_component_toolkit\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import MessageTextInput\nfrom langflow.inputs.inputs import DataInput, HandleInput\nfrom langflow.schema import Data\n\n\nclass ToolCallingAgentComponent(LCToolsAgentComponent):\n    display_name: str = \"Tool Calling Agent\"\n    description: str = \"An agent designed to utilize various tools seamlessly within workflows.\"\n    icon = \"LangChain\"\n    name = \"ToolCallingAgent\"\n\n    inputs = [\n        *LCToolsAgentComponent._base_inputs,\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n            info=\"Language model that the agent utilizes to perform tasks effectively.\",\n        ),\n        MessageTextInput(\n            name=\"system_prompt\",\n            display_name=\"System Prompt\",\n            info=\"System prompt to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n        ),\n        DataInput(\n            name=\"chat_history\",\n            display_name=\"Chat Memory\",\n            is_list=True,\n            advanced=True,\n            info=\"This input stores the chat history, allowing the agent to remember previous conversations.\",\n        ),\n    ]\n\n    def get_chat_history_data(self) -> list[Data] | None:\n        return self.chat_history\n\n    def create_agent_runnable(self):\n        messages = [\n            (\"system\", \"{system_prompt}\"),\n            (\"placeholder\", \"{chat_history}\"),\n            (\"human\", \"{input}\"),\n            (\"placeholder\", \"{agent_scratchpad}\"),\n        ]\n        prompt = ChatPromptTemplate.from_messages(messages)\n        self.validate_tool_names()\n        try:\n            return create_tool_calling_agent(self.llm, self.tools or [], prompt)\n        except NotImplementedError as e:\n            message = f\"{self.display_name} does not support tool calling. Please try using a compatible model.\"\n            raise NotImplementedError(message) from e\n\n    async def to_toolkit(self) -> list[Tool]:\n        component_toolkit = _get_component_toolkit()\n        toolkit = component_toolkit(component=self)\n        tools = toolkit.get_tools(callbacks=self.get_langchain_callbacks())\n        if hasattr(self, \"tools_metadata\"):\n            tools = toolkit.update_tools_metadata(tools=tools)\n        return tools\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "handle_parsing_errors": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "handle_parsing_errors",
                    "value": true,
                    "display_name": "Handle Parse Errors",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Should the Agent fix errors when reading user input for better processing?",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "input_value": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "",
                    "display_name": "Input",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The input provided by the user for the agent to process.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "max_iterations": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_iterations",
                    "value": 15,
                    "display_name": "Max Iterations",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "system_prompt": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "system_prompt",
                    "value": "You are a helpful assistant that can use tools to answer questions and perform tasks.",
                    "display_name": "System Prompt",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "System prompt to guide the agent's behavior.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "verbose": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "verbose",
                    "value": true,
                    "display_name": "Verbose",
                    "advanced": true,
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                }
            },
            "description": "An agent designed to utilize various tools seamlessly within workflows.",
            "icon": "LangChain",
            "base_classes": [
                "AgentExecutor",
                "Message"
            ],
            "display_name": "Tool Calling Agent",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "AgentExecutor"
                    ],
                    "selected": "AgentExecutor",
                    "name": "agent",
                    "hidden": true,
                    "display_name": "Agent",
                    "method": "build_agent",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": false
                },
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "response",
                    "display_name": "Response",
                    "method": "message_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "tools",
                "input_value",
                "handle_parsing_errors",
                "verbose",
                "max_iterations",
                "agent_description",
                "llm",
                "system_prompt",
                "chat_history"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        }
    },
    "custom_component": {
        "CustomComponent": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "# from langflow.field_typing import Data\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Data\n\n\nclass CustomComponent(Component):\n    display_name = \"Custom Component\"\n    description = \"Use as a template to create your own component.\"\n    icon = \"code\"\n    name = \"CustomComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Input Value\",\n            info=\"This is a custom component Input\",\n            value=\"Hello, World!\",\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Data:\n        data = Data(value=self.input_value)\n        self.status = data\n        return data\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "input_value": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "Hello, World!",
                    "display_name": "Input Value",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "This is a custom component Input",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                }
            },
            "description": "Use as a template to create your own component.",
            "icon": "code",
            "base_classes": [
                "Data"
            ],
            "display_name": "Custom Component",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "output",
                    "display_name": "Output",
                    "method": "build_output",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        }
    },
    "data": {
        "APIRequest": {
            "template": {
                "_type": "Component",
                "query_params": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "trace_as_input": true,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "query_params",
                    "value": "",
                    "display_name": "Query Parameters",
                    "advanced": true,
                    "input_types": [
                        "Data"
                    ],
                    "dynamic": false,
                    "info": "The query parameters to append to the URL.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "DataInput"
                },
                "body": {
                    "tool_mode": false,
                    "is_list": true,
                    "list_add_label": "Add More",
                    "table_schema": {
                        "columns": [
                            {
                                "name": "key",
                                "display_name": "Key",
                                "sortable": true,
                                "filterable": true,
                                "formatter": "text",
                                "type": "str",
                                "description": "Parameter name",
                                "default": "None",
                                "disable_edit": false,
                                "edit_mode": "popover",
                                "hidden": false
                            },
                            {
                                "name": "value",
                                "display_name": "Value",
                                "sortable": true,
                                "filterable": true,
                                "description": "Parameter value",
                                "default": "None",
                                "disable_edit": false,
                                "edit_mode": "popover",
                                "hidden": false
                            }
                        ]
                    },
                    "trigger_text": "Open table",
                    "trigger_icon": "Table",
                    "table_icon": "Table",
                    "trace_as_metadata": true,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "body",
                    "value": [],
                    "display_name": "Body",
                    "advanced": true,
                    "input_types": [
                        "Data"
                    ],
                    "dynamic": false,
                    "info": "The body to send with the request as a dictionary (for POST, PATCH, PUT).",
                    "title_case": false,
                    "type": "table",
                    "_input_type": "TableInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "import asyncio\nimport json\nimport re\nimport tempfile\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport aiofiles\nimport aiofiles.os as aiofiles_os\nimport httpx\nimport validators\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    FloatInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    StrInput,\n    TableInput,\n)\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\n\nclass APIRequestComponent(Component):\n    display_name = \"API Request\"\n    description = \"Make HTTP requests using URLs or cURL commands.\"\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    default_keys = [\"urls\", \"method\", \"query_params\"]\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            list=True,\n            info=\"Enter one or more URLs, separated by commas.\",\n            advanced=False,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"curl\",\n            display_name=\"cURL\",\n            info=(\n                \"Paste a curl command to populate the fields. \"\n                \"This will fill in the dictionary fields for headers and body.\"\n            ),\n            advanced=True,\n            real_time_refresh=True,\n            tool_mode=True,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"],\n            info=\"The HTTP method to use.\",\n            real_time_refresh=True,\n        ),\n        BoolInput(\n            name=\"use_curl\",\n            display_name=\"Use cURL\",\n            value=False,\n            info=\"Enable cURL mode to populate fields from a cURL command.\",\n            real_time_refresh=True,\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT).\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Key\",\n                    \"type\": \"str\",\n                    \"description\": \"Parameter name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"description\": \"Parameter value\",\n                },\n            ],\n            value=[],\n            input_types=[\"Data\"],\n            advanced=True,\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request as a dictionary.\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[],\n            advanced=True,\n            input_types=[\"Data\"],\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=5,\n            info=\"The timeout to use for the request.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"follow_redirects\",\n            display_name=\"Follow Redirects\",\n            value=True,\n            info=\"Whether to follow http redirects.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"save_to_file\",\n            display_name=\"Save to File\",\n            value=False,\n            info=\"Save the API response to a temporary file\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_httpx_metadata\",\n            display_name=\"Include HTTPx Metadata\",\n            value=False,\n            info=(\n                \"Include properties such as headers, status_code, response_headers, \"\n                \"and redirection_history in the output.\"\n            ),\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"make_requests\"),\n    ]\n\n    def _parse_json_value(self, value: Any) -> Any:\n        \"\"\"Parse a value that might be a JSON string.\"\"\"\n        if not isinstance(value, str):\n            return value\n\n        try:\n            parsed = json.loads(value)\n        except json.JSONDecodeError:\n            return value\n        else:\n            return parsed\n\n    def _process_body(self, body: Any) -> dict:\n        \"\"\"Process the body input into a valid dictionary.\n\n        Args:\n            body: The body to process, can be dict, str, or list\n        Returns:\n            Processed dictionary\n        \"\"\"\n        if body is None:\n            return {}\n        if isinstance(body, dict):\n            return self._process_dict_body(body)\n        if isinstance(body, str):\n            return self._process_string_body(body)\n        if isinstance(body, list):\n            return self._process_list_body(body)\n\n        return {}\n\n    def _process_dict_body(self, body: dict) -> dict:\n        \"\"\"Process dictionary body by parsing JSON values.\"\"\"\n        return {k: self._parse_json_value(v) for k, v in body.items()}\n\n    def _process_string_body(self, body: str) -> dict:\n        \"\"\"Process string body by attempting JSON parse.\"\"\"\n        try:\n            return self._process_body(json.loads(body))\n        except json.JSONDecodeError:\n            return {\"data\": body}\n\n    def _process_list_body(self, body: list) -> dict:\n        \"\"\"Process list body by converting to key-value dictionary.\"\"\"\n        processed_dict = {}\n\n        try:\n            for item in body:\n                if not self._is_valid_key_value_item(item):\n                    continue\n\n                key = item[\"key\"]\n                value = self._parse_json_value(item[\"value\"])\n                processed_dict[key] = value\n\n        except (KeyError, TypeError, ValueError) as e:\n            self.log(f\"Failed to process body list: {e}\")\n            return {}  # Return empty dictionary instead of None\n\n        return processed_dict\n\n    def _is_valid_key_value_item(self, item: Any) -> bool:\n        \"\"\"Check if an item is a valid key-value dictionary.\"\"\"\n        return isinstance(item, dict) and \"key\" in item and \"value\" in item\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        \"\"\"Parse a cURL command and update build configuration.\n\n        Args:\n            curl: The cURL command to parse\n            build_config: The build configuration to update\n        Returns:\n            Updated build configuration\n        \"\"\"\n        try:\n            parsed = parse_context(curl)\n\n            # Update basic configuration\n            build_config[\"urls\"][\"value\"] = [parsed.url]\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n            build_config[\"headers\"][\"advanced\"] = True\n            build_config[\"body\"][\"advanced\"] = True\n\n            # Process headers\n            headers_list = [{\"key\": k, \"value\": v} for k, v in parsed.headers.items()]\n            build_config[\"headers\"][\"value\"] = headers_list\n\n            if headers_list:\n                build_config[\"headers\"][\"advanced\"] = False\n\n            # Process body data\n            if not parsed.data:\n                build_config[\"body\"][\"value\"] = []\n            elif parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    if isinstance(json_data, dict):\n                        body_list = [\n                            {\"key\": k, \"value\": json.dumps(v) if isinstance(v, dict | list) else str(v)}\n                            for k, v in json_data.items()\n                        ]\n                        build_config[\"body\"][\"value\"] = body_list\n                        build_config[\"body\"][\"advanced\"] = False\n                    else:\n                        build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": json.dumps(json_data)}]\n                        build_config[\"body\"][\"advanced\"] = False\n                except json.JSONDecodeError:\n                    build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": parsed.data}]\n                    build_config[\"body\"][\"advanced\"] = False\n\n        except Exception as exc:\n            msg = f\"Error parsing curl: {exc}\"\n            self.log(msg)\n            raise ValueError(msg) from exc\n\n        return build_config\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        if field_name == \"use_curl\":\n            build_config = self._update_curl_mode(build_config, use_curl=field_value)\n\n            # Fields that should not be reset\n            preserve_fields = {\"timeout\", \"follow_redirects\", \"save_to_file\", \"include_httpx_metadata\", \"use_curl\"}\n\n            # Mapping between input types and their reset values\n            type_reset_mapping = {\n                TableInput: [],\n                BoolInput: False,\n                IntInput: 0,\n                FloatInput: 0.0,\n                MessageTextInput: \"\",\n                StrInput: \"\",\n                MultilineInput: \"\",\n                DropdownInput: \"GET\",\n                DataInput: {},\n            }\n\n            for input_field in self.inputs:\n                # Only reset if field is not in preserve list\n                if input_field.name not in preserve_fields:\n                    reset_value = type_reset_mapping.get(type(input_field), None)\n                    build_config[input_field.name][\"value\"] = reset_value\n                    self.log(f\"Reset field {input_field.name} to {reset_value}\")\n        elif field_name == \"method\" and not self.use_curl:\n            build_config = self._update_method_fields(build_config, field_value)\n        elif field_name == \"curl\" and self.use_curl and field_value:\n            build_config = self.parse_curl(field_value, build_config)\n        return build_config\n\n    def _update_curl_mode(self, build_config: dotdict, *, use_curl: bool) -> dotdict:\n        always_visible = [\"method\", \"use_curl\"]\n\n        for field in self.inputs:\n            field_name = field.name\n            field_config = build_config.get(field_name)\n            if isinstance(field_config, dict):\n                if field_name in always_visible:\n                    field_config[\"advanced\"] = False\n                elif field_name == \"urls\":\n                    field_config[\"advanced\"] = use_curl\n                elif field_name == \"curl\":\n                    field_config[\"advanced\"] = not use_curl\n                    field_config[\"real_time_refresh\"] = use_curl\n                elif field_name in [\"body\", \"headers\"]:\n                    field_config[\"advanced\"] = True  # Always keep body and headers in advanced when use_curl is False\n                else:\n                    field_config[\"advanced\"] = use_curl\n            else:\n                self.log(f\"Expected dict for build_config[{field_name}], got {type(field_config).__name__}\")\n\n        if not use_curl:\n            current_method = build_config.get(\"method\", {}).get(\"value\", \"GET\")\n            build_config = self._update_method_fields(build_config, current_method)\n\n        return build_config\n\n    def _update_method_fields(self, build_config: dotdict, method: str) -> dotdict:\n        common_fields = [\n            \"urls\",\n            \"method\",\n            \"use_curl\",\n        ]\n\n        always_advanced_fields = [\n            \"body\",\n            \"headers\",\n            \"timeout\",\n            \"follow_redirects\",\n            \"save_to_file\",\n            \"include_httpx_metadata\",\n        ]\n\n        body_fields = [\"body\"]\n\n        for field in self.inputs:\n            field_name = field.name\n            field_config = build_config.get(field_name)\n            if isinstance(field_config, dict):\n                if field_name in common_fields:\n                    field_config[\"advanced\"] = False\n                elif field_name in body_fields:\n                    field_config[\"advanced\"] = method not in [\"POST\", \"PUT\", \"PATCH\"]\n                elif field_name in always_advanced_fields:\n                    field_config[\"advanced\"] = True\n                else:\n                    field_config[\"advanced\"] = True\n            else:\n                self.log(f\"Expected dict for build_config[{field_name}], got {type(field_config).__name__}\")\n\n        return build_config\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: dict | None = None,\n        body: Any = None,\n        timeout: int = 5,\n        *,\n        follow_redirects: bool = True,\n        save_to_file: bool = False,\n        include_httpx_metadata: bool = False,\n    ) -> Data:\n        method = method.upper()\n        if method not in {\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"}:\n            msg = f\"Unsupported method: {method}\"\n            raise ValueError(msg)\n\n        # Process body using the new helper method\n        processed_body = self._process_body(body)\n\n        try:\n            response = await client.request(\n                method,\n                url,\n                headers=headers,\n                json=processed_body,\n                timeout=timeout,\n                follow_redirects=follow_redirects,\n            )\n\n            redirection_history = [\n                {\n                    \"url\": redirect.headers.get(\"Location\", str(redirect.url)),\n                    \"status_code\": redirect.status_code,\n                }\n                for redirect in response.history\n            ]\n\n            is_binary, file_path = await self._response_info(response, with_file_path=save_to_file)\n            response_headers = self._headers_to_dict(response.headers)\n\n            metadata: dict[str, Any] = {\n                \"source\": url,\n            }\n\n            if save_to_file:\n                mode = \"wb\" if is_binary else \"w\"\n                encoding = response.encoding if mode == \"w\" else None\n                if file_path:\n                    # Ensure parent directory exists\n                    await aiofiles_os.makedirs(file_path.parent, exist_ok=True)\n                    if is_binary:\n                        async with aiofiles.open(file_path, \"wb\") as f:\n                            await f.write(response.content)\n                            await f.flush()\n                    else:\n                        async with aiofiles.open(file_path, \"w\", encoding=encoding) as f:\n                            await f.write(response.text)\n                            await f.flush()\n                    metadata[\"file_path\"] = str(file_path)\n\n                if include_httpx_metadata:\n                    metadata.update(\n                        {\n                            \"headers\": headers,\n                            \"status_code\": response.status_code,\n                            \"response_headers\": response_headers,\n                            **({\"redirection_history\": redirection_history} if redirection_history else {}),\n                        }\n                    )\n                return Data(data=metadata)\n\n            if is_binary:\n                result = response.content\n            else:\n                try:\n                    result = response.json()\n                except json.JSONDecodeError:\n                    self.log(\"Failed to decode JSON response\")\n                    result = response.text.encode(\"utf-8\")\n\n            metadata.update({\"result\": result})\n\n            if include_httpx_metadata:\n                metadata.update(\n                    {\n                        \"headers\": headers,\n                        \"status_code\": response.status_code,\n                        \"response_headers\": response_headers,\n                        **({\"redirection_history\": redirection_history} if redirection_history else {}),\n                    }\n                )\n            return Data(data=metadata)\n        except httpx.TimeoutException:\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 408,\n                    \"error\": \"Request timed out\",\n                },\n            )\n        except Exception as exc:  # noqa: BLE001\n            self.log(f\"Error making request to {url}\")\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                    **({\"redirection_history\": redirection_history} if redirection_history else {}),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    async def make_requests(self) -> list[Data]:\n        method = self.method\n        urls = [url.strip() for url in self.urls if url.strip()]\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        follow_redirects = self.follow_redirects\n        save_to_file = self.save_to_file\n        include_httpx_metadata = self.include_httpx_metadata\n\n        if self.use_curl and self.curl:\n            self._build_config = self.parse_curl(self.curl, dotdict())\n\n        invalid_urls = [url for url in urls if not validators.url(url)]\n        if invalid_urls:\n            msg = f\"Invalid URLs provided: {invalid_urls}\"\n            raise ValueError(msg)\n\n        if isinstance(self.query_params, str):\n            query_params = dict(parse_qsl(self.query_params))\n        else:\n            query_params = self.query_params.data if self.query_params else {}\n\n        # Process headers here\n        headers = self._process_headers(headers)\n\n        # Process body\n        body = self._process_body(body)\n\n        bodies = [body] * len(urls)\n\n        urls = [self.add_query_params(url, query_params) for url in urls]\n\n        async with httpx.AsyncClient() as client:\n            results = await asyncio.gather(\n                *[\n                    self.make_request(\n                        client,\n                        method,\n                        u,\n                        headers,\n                        rec,\n                        timeout,\n                        follow_redirects=follow_redirects,\n                        save_to_file=save_to_file,\n                        include_httpx_metadata=include_httpx_metadata,\n                    )\n                    for u, rec in zip(urls, bodies, strict=False)\n                ]\n            )\n        self.status = results\n        return results\n\n    async def _response_info(\n        self, response: httpx.Response, *, with_file_path: bool = False\n    ) -> tuple[bool, Path | None]:\n        \"\"\"Determine the file path and whether the response content is binary.\n\n        Args:\n            response (Response): The HTTP response object.\n            with_file_path (bool): Whether to save the response content to a file.\n\n        Returns:\n            Tuple[bool, Path | None]:\n                A tuple containing a boolean indicating if the content is binary and the full file path (if applicable).\n        \"\"\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        is_binary = \"application/octet-stream\" in content_type or \"application/binary\" in content_type\n\n        if not with_file_path:\n            return is_binary, None\n\n        component_temp_dir = Path(tempfile.gettempdir()) / self.__class__.__name__\n\n        # Create directory asynchronously\n        await aiofiles_os.makedirs(component_temp_dir, exist_ok=True)\n\n        filename = None\n        if \"Content-Disposition\" in response.headers:\n            content_disposition = response.headers[\"Content-Disposition\"]\n            filename_match = re.search(r'filename=\"(.+?)\"', content_disposition)\n            if filename_match:\n                extracted_filename = filename_match.group(1)\n                filename = extracted_filename\n\n        # Step 3: Infer file extension or use part of the request URL if no filename\n        if not filename:\n            # Extract the last segment of the URL path\n            url_path = urlparse(str(response.request.url) if response.request else \"\").path\n            base_name = Path(url_path).name  # Get the last segment of the path\n            if not base_name:  # If the path ends with a slash or is empty\n                base_name = \"response\"\n\n            # Infer file extension\n            content_type_to_extension = {\n                \"text/plain\": \".txt\",\n                \"application/json\": \".json\",\n                \"image/jpeg\": \".jpg\",\n                \"image/png\": \".png\",\n                \"application/octet-stream\": \".bin\",\n            }\n            extension = content_type_to_extension.get(content_type, \".bin\" if is_binary else \".txt\")\n            filename = f\"{base_name}{extension}\"\n\n        # Step 4: Define the full file path\n        file_path = component_temp_dir / filename\n\n        # Step 5: Check if file exists asynchronously and handle accordingly\n        try:\n            # Try to create the file exclusively (x mode) to check existence\n            async with aiofiles.open(file_path, \"x\") as _:\n                pass  # File created successfully, we can use this path\n        except FileExistsError:\n            # If file exists, append a timestamp to the filename\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S%f\")\n            file_path = component_temp_dir / f\"{timestamp}-{filename}\"\n\n        return is_binary, file_path\n\n    def _headers_to_dict(self, headers: httpx.Headers) -> dict[str, str]:\n        \"\"\"Convert HTTP headers to a dictionary with lowercased keys.\"\"\"\n        return {k.lower(): v for k, v in headers.items()}\n\n    def _process_headers(self, headers: Any) -> dict:\n        \"\"\"Process the headers input into a valid dictionary.\n\n        Args:\n            headers: The headers to process, can be dict, str, or list\n        Returns:\n            Processed dictionary\n        \"\"\"\n        if headers is None:\n            return {}\n        if isinstance(headers, dict):\n            return headers\n        if isinstance(headers, list):\n            processed_headers = {}\n            try:\n                for item in headers:\n                    if not self._is_valid_key_value_item(item):\n                        continue\n                    key = item[\"key\"]\n                    value = item[\"value\"]\n                    processed_headers[key] = value\n            except (KeyError, TypeError, ValueError) as e:\n                self.log(f\"Failed to process headers list: {e}\")\n                return {}  # Return empty dictionary instead of None\n            return processed_headers\n        return {}\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "curl": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "curl",
                    "value": "",
                    "display_name": "cURL",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.",
                    "real_time_refresh": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "follow_redirects": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "follow_redirects",
                    "value": true,
                    "display_name": "Follow Redirects",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Whether to follow http redirects.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "headers": {
                    "tool_mode": false,
                    "is_list": true,
                    "list_add_label": "Add More",
                    "table_schema": {
                        "columns": [
                            {
                                "name": "key",
                                "display_name": "Header",
                                "sortable": true,
                                "filterable": true,
                                "formatter": "text",
                                "type": "str",
                                "description": "Header name",
                                "default": "None",
                                "disable_edit": false,
                                "edit_mode": "popover",
                                "hidden": false
                            },
                            {
                                "name": "value",
                                "display_name": "Value",
                                "sortable": true,
                                "filterable": true,
                                "formatter": "text",
                                "type": "str",
                                "description": "Header value",
                                "default": "None",
                                "disable_edit": false,
                                "edit_mode": "popover",
                                "hidden": false
                            }
                        ]
                    },
                    "trigger_text": "Open table",
                    "trigger_icon": "Table",
                    "table_icon": "Table",
                    "trace_as_metadata": true,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "headers",
                    "value": [],
                    "display_name": "Headers",
                    "advanced": true,
                    "input_types": [
                        "Data"
                    ],
                    "dynamic": false,
                    "info": "The headers to send with the request as a dictionary.",
                    "title_case": false,
                    "type": "table",
                    "_input_type": "TableInput"
                },
                "include_httpx_metadata": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "include_httpx_metadata",
                    "value": false,
                    "display_name": "Include HTTPx Metadata",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Include properties such as headers, status_code, response_headers, and redirection_history in the output.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "method": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "GET",
                        "POST",
                        "PATCH",
                        "PUT",
                        "DELETE"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "method",
                    "value": "",
                    "display_name": "Method",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The HTTP method to use.",
                    "real_time_refresh": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "save_to_file": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "save_to_file",
                    "value": false,
                    "display_name": "Save to File",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Save the API response to a temporary file",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "timeout": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "timeout",
                    "value": 5,
                    "display_name": "Timeout",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The timeout to use for the request.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "urls": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": true,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "urls",
                    "value": "",
                    "display_name": "URLs",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Enter one or more URLs, separated by commas.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "use_curl": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "use_curl",
                    "value": false,
                    "display_name": "Use cURL",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Enable cURL mode to populate fields from a cURL command.",
                    "real_time_refresh": true,
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                }
            },
            "description": "Make HTTP requests using URLs or cURL commands.",
            "icon": "Globe",
            "base_classes": [
                "Data"
            ],
            "display_name": "API Request",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "data",
                    "display_name": "Data",
                    "method": "make_requests",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "urls",
                "curl",
                "method",
                "use_curl",
                "query_params",
                "body",
                "headers",
                "timeout",
                "follow_redirects",
                "save_to_file",
                "include_httpx_metadata"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "Directory": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langflow.base.data.utils import TEXT_FILE_TYPES, parallel_load_data, parse_text_file_to_data, retrieve_file_paths\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, IntInput, MessageTextInput, MultiselectInput\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.template import Output\n\n\nclass DirectoryComponent(Component):\n    display_name = \"Directory\"\n    description = \"Recursively load files from a directory.\"\n    icon = \"folder\"\n    name = \"Directory\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"path\",\n            display_name=\"Path\",\n            info=\"Path to the directory to load files from. Defaults to current directory ('.')\",\n            value=\".\",\n            tool_mode=True,\n        ),\n        MultiselectInput(\n            name=\"types\",\n            display_name=\"File Types\",\n            info=\"File types to load. Select one or more types or leave empty to load all supported types.\",\n            options=TEXT_FILE_TYPES,\n            value=[],\n        ),\n        IntInput(\n            name=\"depth\",\n            display_name=\"Depth\",\n            info=\"Depth to search for files.\",\n            value=0,\n        ),\n        IntInput(\n            name=\"max_concurrency\",\n            display_name=\"Max Concurrency\",\n            advanced=True,\n            info=\"Maximum concurrency for loading files.\",\n            value=2,\n        ),\n        BoolInput(\n            name=\"load_hidden\",\n            display_name=\"Load Hidden\",\n            advanced=True,\n            info=\"If true, hidden files will be loaded.\",\n        ),\n        BoolInput(\n            name=\"recursive\",\n            display_name=\"Recursive\",\n            advanced=True,\n            info=\"If true, the search will be recursive.\",\n        ),\n        BoolInput(\n            name=\"silent_errors\",\n            display_name=\"Silent Errors\",\n            advanced=True,\n            info=\"If true, errors will not raise an exception.\",\n        ),\n        BoolInput(\n            name=\"use_multithreading\",\n            display_name=\"Use Multithreading\",\n            advanced=True,\n            info=\"If true, multithreading will be used.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"load_directory\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    def load_directory(self) -> list[Data]:\n        path = self.path\n        types = self.types\n        depth = self.depth\n        max_concurrency = self.max_concurrency\n        load_hidden = self.load_hidden\n        recursive = self.recursive\n        silent_errors = self.silent_errors\n        use_multithreading = self.use_multithreading\n\n        resolved_path = self.resolve_path(path)\n\n        # If no types are specified, use all supported types\n        if not types:\n            types = TEXT_FILE_TYPES\n\n        # Check if all specified types are valid\n        invalid_types = [t for t in types if t not in TEXT_FILE_TYPES]\n        if invalid_types:\n            msg = f\"Invalid file types specified: {invalid_types}. Valid types are: {TEXT_FILE_TYPES}\"\n            raise ValueError(msg)\n\n        valid_types = types\n\n        file_paths = retrieve_file_paths(\n            resolved_path, load_hidden=load_hidden, recursive=recursive, depth=depth, types=valid_types\n        )\n\n        loaded_data = []\n        if use_multithreading:\n            loaded_data = parallel_load_data(file_paths, silent_errors=silent_errors, max_concurrency=max_concurrency)\n        else:\n            loaded_data = [parse_text_file_to_data(file_path, silent_errors=silent_errors) for file_path in file_paths]\n\n        valid_data = [x for x in loaded_data if x is not None and isinstance(x, Data)]\n        self.status = valid_data\n        return valid_data\n\n    def as_dataframe(self) -> DataFrame:\n        return DataFrame(self.load_directory())\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "depth": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "depth",
                    "value": 0,
                    "display_name": "Depth",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Depth to search for files.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "load_hidden": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "load_hidden",
                    "value": false,
                    "display_name": "Load Hidden",
                    "advanced": true,
                    "dynamic": false,
                    "info": "If true, hidden files will be loaded.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "max_concurrency": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_concurrency",
                    "value": 2,
                    "display_name": "Max Concurrency",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Maximum concurrency for loading files.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "path": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "path",
                    "value": ".",
                    "display_name": "Path",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Path to the directory to load files from. Defaults to current directory ('.')",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "recursive": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "recursive",
                    "value": false,
                    "display_name": "Recursive",
                    "advanced": true,
                    "dynamic": false,
                    "info": "If true, the search will be recursive.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "silent_errors": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "silent_errors",
                    "value": false,
                    "display_name": "Silent Errors",
                    "advanced": true,
                    "dynamic": false,
                    "info": "If true, errors will not raise an exception.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "types": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "txt",
                        "md",
                        "mdx",
                        "csv",
                        "json",
                        "yaml",
                        "yml",
                        "xml",
                        "html",
                        "htm",
                        "pdf",
                        "docx",
                        "py",
                        "sh",
                        "sql",
                        "js",
                        "ts",
                        "tsx"
                    ],
                    "combobox": false,
                    "list": true,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "types",
                    "value": [],
                    "display_name": "File Types",
                    "advanced": false,
                    "dynamic": false,
                    "info": "File types to load. Select one or more types or leave empty to load all supported types.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultiselectInput"
                },
                "use_multithreading": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "use_multithreading",
                    "value": false,
                    "display_name": "Use Multithreading",
                    "advanced": true,
                    "dynamic": false,
                    "info": "If true, multithreading will be used.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                }
            },
            "description": "Recursively load files from a directory.",
            "icon": "folder",
            "base_classes": [
                "Data",
                "DataFrame"
            ],
            "display_name": "Directory",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "data",
                    "display_name": "Data",
                    "method": "load_directory",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "DataFrame"
                    ],
                    "selected": "DataFrame",
                    "name": "dataframe",
                    "display_name": "DataFrame",
                    "method": "as_dataframe",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "path",
                "types",
                "depth",
                "max_concurrency",
                "load_hidden",
                "recursive",
                "silent_errors",
                "use_multithreading"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "URL": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "import re\n\nfrom langchain_community.document_loaders import AsyncHtmlLoader, WebBaseLoader\n\nfrom langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\n\nclass URLComponent(Component):\n    display_name = \"URL\"\n    description = \"Load and retrive data from specified URLs.\"\n    icon = \"layout-template\"\n    name = \"URL\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'Raw HTML' for the raw HTML content.\",\n            options=[\"Text\", \"Raw HTML\"],\n            value=\"Text\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\"),\n        Output(display_name=\"Message\", name=\"text\", method=\"fetch_content_text\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    def ensure_url(self, string: str) -> str:\n        \"\"\"Ensures the given string is a URL by adding 'http://' if it doesn't start with 'http://' or 'https://'.\n\n        Raises an error if the string is not a valid URL.\n\n        Parameters:\n            string (str): The string to be checked and possibly modified.\n\n        Returns:\n            str: The modified string that is ensured to be a URL.\n\n        Raises:\n            ValueError: If the string is not a valid URL.\n        \"\"\"\n        if not string.startswith((\"http://\", \"https://\")):\n            string = \"http://\" + string\n\n        # Basic URL validation regex\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\"  # optional protocol\n            r\"(www\\.)?\"  # optional www\n            r\"([a-zA-Z0-9.-]+)\"  # domain\n            r\"(\\.[a-zA-Z]{2,})?\"  # top-level domain\n            r\"(:\\d+)?\"  # optional port\n            r\"(\\/[^\\s]*)?$\",  # optional path\n            re.IGNORECASE,\n        )\n\n        if not url_regex.match(string):\n            msg = f\"Invalid URL: {string}\"\n            raise ValueError(msg)\n\n        return string\n\n    def fetch_content(self) -> list[Data]:\n        urls = [self.ensure_url(url.strip()) for url in self.urls if url.strip()]\n        if self.format == \"Raw HTML\":\n            loader = AsyncHtmlLoader(web_path=urls, encoding=\"utf-8\")\n        else:\n            loader = WebBaseLoader(web_paths=urls, encoding=\"utf-8\")\n        docs = loader.load()\n        data = [Data(text=doc.page_content, **doc.metadata) for doc in docs]\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        data = self.fetch_content()\n\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        return DataFrame(self.fetch_content())\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "format": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "Text",
                        "Raw HTML"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "format",
                    "value": "Text",
                    "display_name": "Output Format",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Output Format. Use 'Text' to extract the text from the HTML or 'Raw HTML' for the raw HTML content.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "urls": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": true,
                    "list_add_label": "Add URL",
                    "required": false,
                    "placeholder": "Enter a URL...",
                    "show": true,
                    "name": "urls",
                    "value": "",
                    "display_name": "URLs",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                }
            },
            "description": "Load and retrive data from specified URLs.",
            "icon": "layout-template",
            "base_classes": [
                "Data",
                "DataFrame",
                "Message"
            ],
            "display_name": "URL",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "data",
                    "display_name": "Data",
                    "method": "fetch_content",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "text",
                    "display_name": "Message",
                    "method": "fetch_content_text",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "DataFrame"
                    ],
                    "selected": "DataFrame",
                    "name": "dataframe",
                    "display_name": "DataFrame",
                    "method": "as_dataframe",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "urls",
                "format"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "Webhook": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "import json\n\nfrom langflow.custom import Component\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema import Data\n\n\nclass WebhookComponent(Component):\n    display_name = \"Webhook\"\n    description = \"Defines a webhook input for the flow.\"\n    name = \"Webhook\"\n    icon = \"webhook\"\n\n    inputs = [\n        MultilineInput(\n            name=\"data\",\n            display_name=\"Payload\",\n            info=\"Receives a payload from external systems via HTTP POST.\",\n        )\n    ]\n    outputs = [\n        Output(display_name=\"Data\", name=\"output_data\", method=\"build_data\"),\n    ]\n\n    def build_data(self) -> Data:\n        message: str | Data = \"\"\n        if not self.data:\n            self.status = \"No data provided.\"\n            return Data(data={})\n        try:\n            body = json.loads(self.data or \"{}\")\n        except json.JSONDecodeError:\n            body = {\"payload\": self.data}\n            message = f\"Invalid JSON payload. Please check the format.\\n\\n{self.data}\"\n        data = Data(data=body)\n        if not message:\n            message = data\n        self.status = message\n        return data\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "data": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "data",
                    "value": "",
                    "display_name": "Payload",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Receives a payload from external systems via HTTP POST.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                }
            },
            "description": "Defines a webhook input for the flow.",
            "icon": "webhook",
            "base_classes": [
                "Data"
            ],
            "display_name": "Webhook",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "output_data",
                    "display_name": "Data",
                    "method": "build_data",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "data"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        }
    },
    "inputs": {
        "ChatInput": {
            "template": {
                "_type": "Component",
                "files": {
                    "trace_as_metadata": true,
                    "file_path": "",
                    "fileTypes": [
                        "txt",
                        "md",
                        "mdx",
                        "csv",
                        "json",
                        "yaml",
                        "yml",
                        "xml",
                        "html",
                        "htm",
                        "pdf",
                        "docx",
                        "py",
                        "sh",
                        "sql",
                        "js",
                        "ts",
                        "tsx",
                        "jpg",
                        "jpeg",
                        "png",
                        "bmp",
                        "image"
                    ],
                    "list": true,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "files",
                    "value": "",
                    "display_name": "Files",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Files to be sent with the message.",
                    "title_case": false,
                    "type": "file",
                    "_input_type": "FileInput"
                },
                "background_color": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "background_color",
                    "value": "",
                    "display_name": "Background Color",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The background color of the icon.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "chat_icon": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "chat_icon",
                    "value": "",
                    "display_name": "Icon",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The icon of the message.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        background_color = self.background_color\n        text_color = self.text_color\n        icon = self.chat_icon\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n            properties={\n                \"background_color\": background_color,\n                \"text_color\": text_color,\n                \"icon\": icon,\n            },\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "input_value": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "",
                    "display_name": "Text",
                    "advanced": false,
                    "input_types": [],
                    "dynamic": false,
                    "info": "Message to be passed as input.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "sender": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "Machine",
                        "User"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender",
                    "value": "User",
                    "display_name": "Sender Type",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Type of sender.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender_name": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender_name",
                    "value": "User",
                    "display_name": "Sender Name",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Name of the sender.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "session_id": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": "",
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "should_store_message": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "should_store_message",
                    "value": true,
                    "display_name": "Store Messages",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Store the message in the history.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "text_color": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "text_color",
                    "value": "",
                    "display_name": "Text Color",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The text color of the name",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                }
            },
            "description": "Get chat inputs from the Playground.",
            "icon": "MessagesSquare",
            "base_classes": [
                "Message"
            ],
            "display_name": "Chat Input",
            "documentation": "",
            "minimized": true,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "message",
                    "display_name": "Message",
                    "method": "message_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_value",
                "should_store_message",
                "sender",
                "sender_name",
                "session_id",
                "files",
                "background_color",
                "chat_icon",
                "text_color"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "TextInput": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "input_value": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "",
                    "display_name": "Text",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Text to be passed as input.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                }
            },
            "description": "Get text inputs from the Playground.",
            "icon": "type",
            "base_classes": [
                "Message"
            ],
            "display_name": "Text Input",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "text",
                    "display_name": "Message",
                    "method": "text_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        }
    },
    "logic": {
        "ConditionalRouter": {
            "template": {
                "_type": "Component",
                "case_sensitive": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "case_sensitive",
                    "value": false,
                    "display_name": "Case Sensitive",
                    "advanced": false,
                    "dynamic": false,
                    "info": "If true, the comparison will be case sensitive.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "import re\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass ConditionalRouterComponent(Component):\n    display_name = \"If-Else\"\n    description = \"Routes an input message to a corresponding output based on text comparison.\"\n    icon = \"split\"\n    name = \"ConditionalRouter\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.__iteration_updated = False\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Text Input\",\n            info=\"The primary text input for the operation.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\", \"regex\"],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            real_time_refresh=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=False,\n        ),\n        MessageInput(\n            name=\"message\",\n            display_name=\"Message\",\n            info=\"The message to pass through either route.\",\n        ),\n        IntInput(\n            name=\"max_iterations\",\n            display_name=\"Max Iterations\",\n            info=\"The maximum number of iterations for the conditional router.\",\n            value=10,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"default_route\",\n            display_name=\"Default Route\",\n            options=[\"true_result\", \"false_result\"],\n            info=\"The default route to take when max iterations are reached.\",\n            value=\"false_result\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\"),\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\"),\n    ]\n\n    def _pre_run_setup(self):\n        self.__iteration_updated = False\n\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool) -> bool:\n        if not case_sensitive and operator != \"regex\":\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        if operator == \"not equals\":\n            return input_text != match_text\n        if operator == \"contains\":\n            return match_text in input_text\n        if operator == \"starts with\":\n            return input_text.startswith(match_text)\n        if operator == \"ends with\":\n            return input_text.endswith(match_text)\n        if operator == \"regex\":\n            try:\n                return bool(re.match(match_text, input_text))\n            except re.error:\n                return False  # Return False if the regex is invalid\n        return False\n\n    def iterate_and_stop_once(self, route_to_stop: str):\n        if not self.__iteration_updated:\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\n            self.__iteration_updated = True\n            if self.ctx.get(f\"{self._id}_iteration\", 0) >= self.max_iterations and route_to_stop == self.default_route:\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\n            self.stop(route_to_stop)\n\n    def true_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n        if result:\n            self.status = self.message\n            self.iterate_and_stop_once(\"false_result\")\n            return self.message\n        self.iterate_and_stop_once(\"true_result\")\n        return Message(content=\"\")\n\n    def false_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n        if not result:\n            self.status = self.message\n            self.iterate_and_stop_once(\"true_result\")\n            return self.message\n        self.iterate_and_stop_once(\"false_result\")\n        return Message(content=\"\")\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        if field_name == \"operator\":\n            if field_value == \"regex\":\n                build_config.pop(\"case_sensitive\", None)\n\n            # Ensure case_sensitive is present for all other operators\n            elif \"case_sensitive\" not in build_config:\n                case_sensitive_input = next(\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\n                )\n                if case_sensitive_input:\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\n        return build_config\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "default_route": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "true_result",
                        "false_result"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "default_route",
                    "value": "false_result",
                    "display_name": "Default Route",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The default route to take when max iterations are reached.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "input_text": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "input_text",
                    "value": "",
                    "display_name": "Text Input",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The primary text input for the operation.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "match_text": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "match_text",
                    "value": "",
                    "display_name": "Match Text",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The text input to compare against.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "max_iterations": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_iterations",
                    "value": 10,
                    "display_name": "Max Iterations",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The maximum number of iterations for the conditional router.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "message": {
                    "trace_as_input": true,
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "message",
                    "value": "",
                    "display_name": "Message",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The message to pass through either route.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageInput"
                },
                "operator": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "equals",
                        "not equals",
                        "contains",
                        "starts with",
                        "ends with",
                        "regex"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "operator",
                    "value": "equals",
                    "display_name": "Operator",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The operator to apply for comparing the texts.",
                    "real_time_refresh": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                }
            },
            "description": "Routes an input message to a corresponding output based on text comparison.",
            "icon": "split",
            "base_classes": [
                "Message"
            ],
            "display_name": "If-Else",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "true_result",
                    "display_name": "True",
                    "method": "true_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "false_result",
                    "display_name": "False",
                    "method": "false_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_text",
                "match_text",
                "operator",
                "case_sensitive",
                "message",
                "max_iterations",
                "default_route"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "DataConditionalRouter": {
            "template": {
                "_type": "Component",
                "data_input": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": true,
                    "list_add_label": "Add More",
                    "trace_as_input": true,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "data_input",
                    "value": "",
                    "display_name": "Data Input",
                    "advanced": false,
                    "input_types": [
                        "Data"
                    ],
                    "dynamic": false,
                    "info": "The Data object or list of Data objects to process",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "DataInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, MessageTextInput, Output\nfrom langflow.schema import Data, dotdict\n\n\nclass DataConditionalRouterComponent(Component):\n    display_name = \"Condition\"\n    description = \"Route Data object(s) based on a condition applied to a specified key, including boolean validation.\"\n    icon = \"split\"\n    name = \"DataConditionalRouter\"\n    legacy = True\n\n    inputs = [\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Data Input\",\n            info=\"The Data object or list of Data objects to process\",\n            is_list=True,\n        ),\n        MessageTextInput(\n            name=\"key_name\",\n            display_name=\"Key Name\",\n            info=\"The name of the key in the Data object(s) to check\",\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\", \"boolean validator\"],\n            info=\"The operator to apply for comparing the values. 'boolean validator' treats the value as a boolean.\",\n            value=\"equals\",\n        ),\n        MessageTextInput(\n            name=\"compare_value\",\n            display_name=\"Match Text\",\n            info=\"The value to compare against (not used for boolean validator)\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True Output\", name=\"true_output\", method=\"process_data\"),\n        Output(display_name=\"False Output\", name=\"false_output\", method=\"process_data\"),\n    ]\n\n    def compare_values(self, item_value: str, compare_value: str, operator: str) -> bool:\n        if operator == \"equals\":\n            return item_value == compare_value\n        if operator == \"not equals\":\n            return item_value != compare_value\n        if operator == \"contains\":\n            return compare_value in item_value\n        if operator == \"starts with\":\n            return item_value.startswith(compare_value)\n        if operator == \"ends with\":\n            return item_value.endswith(compare_value)\n        if operator == \"boolean validator\":\n            return self.parse_boolean(item_value)\n        return False\n\n    def parse_boolean(self, value):\n        if isinstance(value, bool):\n            return value\n        if isinstance(value, str):\n            return value.lower() in {\"true\", \"1\", \"yes\", \"y\", \"on\"}\n        return bool(value)\n\n    def validate_input(self, data_item: Data) -> bool:\n        if not isinstance(data_item, Data):\n            self.status = \"Input is not a Data object\"\n            return False\n        if self.key_name not in data_item.data:\n            self.status = f\"Key '{self.key_name}' not found in Data\"\n            return False\n        return True\n\n    def process_data(self) -> Data | list[Data]:\n        if isinstance(self.data_input, list):\n            true_output = []\n            false_output = []\n            for item in self.data_input:\n                if self.validate_input(item):\n                    result = self.process_single_data(item)\n                    if result:\n                        true_output.append(item)\n                    else:\n                        false_output.append(item)\n            self.stop(\"false_output\" if true_output else \"true_output\")\n            return true_output or false_output\n        if not self.validate_input(self.data_input):\n            return Data(data={\"error\": self.status})\n        result = self.process_single_data(self.data_input)\n        self.stop(\"false_output\" if result else \"true_output\")\n        return self.data_input\n\n    def process_single_data(self, data_item: Data) -> bool:\n        item_value = data_item.data[self.key_name]\n        operator = self.operator\n\n        if operator == \"boolean validator\":\n            condition_met = self.parse_boolean(item_value)\n            condition_description = f\"Boolean validation of '{self.key_name}'\"\n        else:\n            compare_value = self.compare_value\n            condition_met = self.compare_values(str(item_value), compare_value, operator)\n            condition_description = f\"{self.key_name} {operator} {compare_value}\"\n\n        if condition_met:\n            self.status = f\"Condition met: {condition_description}\"\n            return True\n        self.status = f\"Condition not met: {condition_description}\"\n        return False\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"operator\":\n            if field_value == \"boolean validator\":\n                build_config[\"compare_value\"][\"show\"] = False\n                build_config[\"compare_value\"][\"advanced\"] = True\n                build_config[\"compare_value\"][\"value\"] = None\n            else:\n                build_config[\"compare_value\"][\"show\"] = True\n                build_config[\"compare_value\"][\"advanced\"] = False\n\n        return build_config\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "compare_value": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "compare_value",
                    "value": "",
                    "display_name": "Match Text",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The value to compare against (not used for boolean validator)",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "key_name": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "key_name",
                    "value": "",
                    "display_name": "Key Name",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The name of the key in the Data object(s) to check",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "operator": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "equals",
                        "not equals",
                        "contains",
                        "starts with",
                        "ends with",
                        "boolean validator"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "operator",
                    "value": "equals",
                    "display_name": "Operator",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The operator to apply for comparing the values. 'boolean validator' treats the value as a boolean.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                }
            },
            "description": "Route Data object(s) based on a condition applied to a specified key, including boolean validation.",
            "icon": "split",
            "base_classes": [
                "Data"
            ],
            "display_name": "Condition",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "true_output",
                    "display_name": "True Output",
                    "method": "process_data",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "false_output",
                    "display_name": "False Output",
                    "method": "process_data",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "data_input",
                "key_name",
                "operator",
                "compare_value"
            ],
            "beta": false,
            "legacy": true,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "FlowTool": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from typing import Any\n\nfrom loguru import logger\nfrom typing_extensions import override\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.base.tools.flow_tool import FlowTool\nfrom langflow.field_typing import Tool\nfrom langflow.graph.graph.base import Graph\nfrom langflow.helpers.flow import get_flow_inputs\nfrom langflow.io import BoolInput, DropdownInput, Output, StrInput\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\n\nclass FlowToolComponent(LCToolComponent):\n    display_name = \"Flow as Tool [Deprecated]\"\n    description = \"Construct a Tool from a function that runs the loaded Flow.\"\n    field_order = [\"flow_name\", \"name\", \"description\", \"return_direct\"]\n    trace_type = \"tool\"\n    name = \"FlowTool\"\n    legacy: bool = True\n    icon = \"hammer\"\n\n    async def get_flow_names(self) -> list[str]:\n        flow_datas = await self.alist_flows()\n        return [flow_data.data[\"name\"] for flow_data in flow_datas]\n\n    async def get_flow(self, flow_name: str) -> Data | None:\n        \"\"\"Retrieves a flow by its name.\n\n        Args:\n            flow_name (str): The name of the flow to retrieve.\n\n        Returns:\n            Optional[Text]: The flow record if found, None otherwise.\n        \"\"\"\n        flow_datas = await self.alist_flows()\n        for flow_data in flow_datas:\n            if flow_data.data[\"name\"] == flow_name:\n                return flow_data\n        return None\n\n    @override\n    async def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"flow_name\":\n            build_config[\"flow_name\"][\"options\"] = self.get_flow_names()\n\n        return build_config\n\n    inputs = [\n        DropdownInput(\n            name=\"flow_name\", display_name=\"Flow Name\", info=\"The name of the flow to run.\", refresh_button=True\n        ),\n        StrInput(\n            name=\"tool_name\",\n            display_name=\"Name\",\n            info=\"The name of the tool.\",\n        ),\n        StrInput(\n            name=\"tool_description\",\n            display_name=\"Description\",\n            info=\"The description of the tool; defaults to the Flow's description.\",\n        ),\n        BoolInput(\n            name=\"return_direct\",\n            display_name=\"Return Direct\",\n            info=\"Return the result directly from the Tool.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"api_build_tool\", display_name=\"Tool\", method=\"build_tool\"),\n    ]\n\n    async def build_tool(self) -> Tool:\n        FlowTool.model_rebuild()\n        if \"flow_name\" not in self._attributes or not self._attributes[\"flow_name\"]:\n            msg = \"Flow name is required\"\n            raise ValueError(msg)\n        flow_name = self._attributes[\"flow_name\"]\n        flow_data = await self.get_flow(flow_name)\n        if not flow_data:\n            msg = \"Flow not found.\"\n            raise ValueError(msg)\n        graph = Graph.from_payload(\n            flow_data.data[\"data\"],\n            user_id=str(self.user_id),\n        )\n        try:\n            graph.set_run_id(self.graph.run_id)\n        except Exception:  # noqa: BLE001\n            logger.opt(exception=True).warning(\"Failed to set run_id\")\n        inputs = get_flow_inputs(graph)\n        tool_description = self.tool_description.strip() or flow_data.description\n        tool = FlowTool(\n            name=self.tool_name,\n            description=tool_description,\n            graph=graph,\n            return_direct=self.return_direct,\n            inputs=inputs,\n            flow_id=str(flow_data.id),\n            user_id=str(self.user_id),\n            session_id=self.graph.session_id if hasattr(self, \"graph\") else None,\n        )\n        description_repr = repr(tool.description).strip(\"'\")\n        args_str = \"\\n\".join([f\"- {arg_name}: {arg_data['description']}\" for arg_name, arg_data in tool.args.items()])\n        self.status = f\"{description_repr}\\nArguments:\\n{args_str}\"\n        return tool\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "flow_name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "flow_name",
                    "value": "",
                    "display_name": "Flow Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The name of the flow to run.",
                    "refresh_button": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "return_direct": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "return_direct",
                    "value": false,
                    "display_name": "Return Direct",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Return the result directly from the Tool.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "tool_description": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "tool_description",
                    "value": "",
                    "display_name": "Description",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The description of the tool; defaults to the Flow's description.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "tool_name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "tool_name",
                    "value": "",
                    "display_name": "Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The name of the tool.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                }
            },
            "description": "Construct a Tool from a function that runs the loaded Flow.",
            "icon": "hammer",
            "base_classes": [
                "Tool"
            ],
            "display_name": "Flow as Tool [Deprecated]",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Tool"
                    ],
                    "selected": "Tool",
                    "name": "api_build_tool",
                    "display_name": "Tool",
                    "method": "build_tool",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "flow_name",
                "tool_name",
                "tool_description",
                "return_direct"
            ],
            "beta": false,
            "legacy": true,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "Listen": {
            "template": {
                "_type": "CustomComponent",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langflow.custom import CustomComponent\nfrom langflow.schema import Data\n\n\nclass ListenComponent(CustomComponent):\n    display_name = \"Listen\"\n    description = \"A component to listen for a notification.\"\n    name = \"Listen\"\n    beta: bool = True\n    icon = \"Radio\"\n\n    def build_config(self):\n        return {\n            \"name\": {\n                \"display_name\": \"Name\",\n                \"info\": \"The name of the notification to listen for.\",\n            },\n        }\n\n    def build(self, name: str) -> Data:\n        state = self.get_state(name)\n        self._set_successors_ids()\n        self.status = state\n        return state\n\n    def _set_successors_ids(self):\n        self._vertex.is_state = True\n        successors = self._vertex.graph.successor_map.get(self._vertex.id, [])\n        return successors + self._vertex.graph.activated_vertices\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "name": {
                    "type": "str",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": false,
                    "fileTypes": [],
                    "file_path": "",
                    "name": "name",
                    "display_name": "Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The name of the notification to listen for.",
                    "load_from_db": false,
                    "title_case": false,
                    "input_types": [
                        "Text"
                    ]
                }
            },
            "description": "A component to listen for a notification.",
            "icon": "Radio",
            "base_classes": [
                "Data"
            ],
            "display_name": "Listen",
            "documentation": "",
            "minimized": false,
            "custom_fields": {
                "name": null
            },
            "output_types": [
                "Data"
            ],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "data",
                    "hidden": null,
                    "display_name": "Data",
                    "method": null,
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": null,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [],
            "beta": true,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "LoopComponent": {
            "template": {
                "_type": "Component",
                "data": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "trace_as_input": true,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "data",
                    "value": "",
                    "display_name": "Data",
                    "advanced": false,
                    "input_types": [
                        "Data"
                    ],
                    "dynamic": false,
                    "info": "The initial list of Data objects to iterate over.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "DataInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langflow.custom import Component\nfrom langflow.io import DataInput, Output\nfrom langflow.schema import Data\n\n\nclass LoopComponent(Component):\n    display_name = \"Loop\"\n    description = (\n        \"Iterates over a list of Data objects, outputting one item at a time and aggregating results from loop inputs.\"\n    )\n    icon = \"infinity\"\n\n    inputs = [\n        DataInput(\n            name=\"data\",\n            display_name=\"Data\",\n            info=\"The initial list of Data objects to iterate over.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Item\", name=\"item\", method=\"item_output\", allows_loop=True),\n        Output(display_name=\"Done\", name=\"done\", method=\"done_output\"),\n    ]\n\n    def initialize_data(self) -> None:\n        \"\"\"Initialize the data list, context index, and aggregated list.\"\"\"\n        if self.ctx.get(f\"{self._id}_initialized\", False):\n            return\n\n        # Ensure data is a list of Data objects\n        data_list = self._validate_data(self.data)\n\n        # Store the initial data and context variables\n        self.update_ctx(\n            {\n                f\"{self._id}_data\": data_list,\n                f\"{self._id}_index\": 0,\n                f\"{self._id}_aggregated\": [],\n                f\"{self._id}_initialized\": True,\n            }\n        )\n\n    def _validate_data(self, data):\n        \"\"\"Validate and return a list of Data objects.\"\"\"\n        if isinstance(data, Data):\n            return [data]\n        if isinstance(data, list) and all(isinstance(item, Data) for item in data):\n            return data\n        msg = \"The 'data' input must be a list of Data objects or a single Data object.\"\n        raise TypeError(msg)\n\n    def evaluate_stop_loop(self) -> bool:\n        \"\"\"Evaluate whether to stop item or done output.\"\"\"\n        current_index = self.ctx.get(f\"{self._id}_index\", 0)\n        data_length = len(self.ctx.get(f\"{self._id}_data\", []))\n        return current_index > data_length\n\n    def item_output(self) -> Data:\n        \"\"\"Output the next item in the list or stop if done.\"\"\"\n        self.initialize_data()\n        current_item = Data(text=\"\")\n\n        if self.evaluate_stop_loop():\n            self.stop(\"item\")\n            return Data(text=\"\")\n\n        # Get data list and current index\n        data_list, current_index = self.loop_variables()\n        if current_index < len(data_list):\n            # Output current item and increment index\n            try:\n                current_item = data_list[current_index]\n            except IndexError:\n                current_item = Data(text=\"\")\n        self.aggregated_output()\n        self.update_ctx({f\"{self._id}_index\": current_index + 1})\n        return current_item\n\n    def done_output(self) -> Data:\n        \"\"\"Trigger the done output when iteration is complete.\"\"\"\n        self.initialize_data()\n\n        if self.evaluate_stop_loop():\n            self.stop(\"item\")\n            self.start(\"done\")\n\n            return self.ctx.get(f\"{self._id}_aggregated\", [])\n        self.stop(\"done\")\n        return Data(text=\"\")\n\n    def loop_variables(self):\n        \"\"\"Retrieve loop variables from context.\"\"\"\n        return (\n            self.ctx.get(f\"{self._id}_data\", []),\n            self.ctx.get(f\"{self._id}_index\", 0),\n        )\n\n    def aggregated_output(self) -> Data:\n        \"\"\"Return the aggregated list once all items are processed.\"\"\"\n        self.initialize_data()\n\n        # Get data list and aggregated list\n        data_list = self.ctx.get(f\"{self._id}_data\", [])\n        aggregated = self.ctx.get(f\"{self._id}_aggregated\", [])\n\n        # Check if loop input is provided and append to aggregated list\n        if self.item is not None and not isinstance(self.item, str) and len(aggregated) <= len(data_list):\n            aggregated.append(self.item)\n            self.update_ctx({f\"{self._id}_aggregated\": aggregated})\n        return aggregated\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                }
            },
            "description": "Iterates over a list of Data objects, outputting one item at a time and aggregating results from loop inputs.",
            "icon": "infinity",
            "base_classes": [
                "Data"
            ],
            "display_name": "Loop",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "item",
                    "display_name": "Item",
                    "method": "item_output",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": true,
                    "tool_mode": true
                },
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "done",
                    "display_name": "Done",
                    "method": "done_output",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "data"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "Notify": {
            "template": {
                "_type": "CustomComponent",
                "data": {
                    "type": "Data | None",
                    "required": false,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": false,
                    "fileTypes": [],
                    "file_path": "",
                    "name": "data",
                    "display_name": "Data",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The data to store.",
                    "load_from_db": false,
                    "title_case": false
                },
                "append": {
                    "type": "bool",
                    "required": false,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": false,
                    "value": false,
                    "fileTypes": [],
                    "file_path": "",
                    "name": "append",
                    "display_name": "Append",
                    "advanced": false,
                    "dynamic": false,
                    "info": "If True, the record will be appended to the notification.",
                    "load_from_db": false,
                    "title_case": false
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langflow.custom import CustomComponent\nfrom langflow.schema import Data\n\n\nclass NotifyComponent(CustomComponent):\n    display_name = \"Notify\"\n    description = \"A component to generate a notification to Get Notified component.\"\n    icon = \"Notify\"\n    name = \"Notify\"\n    beta: bool = True\n\n    def build_config(self):\n        return {\n            \"name\": {\"display_name\": \"Name\", \"info\": \"The name of the notification.\"},\n            \"data\": {\"display_name\": \"Data\", \"info\": \"The data to store.\"},\n            \"append\": {\n                \"display_name\": \"Append\",\n                \"info\": \"If True, the record will be appended to the notification.\",\n            },\n        }\n\n    def build(self, name: str, *, data: Data | None = None, append: bool = False) -> Data:\n        if data and not isinstance(data, Data):\n            if isinstance(data, str):\n                data = Data(text=data)\n            elif isinstance(data, dict):\n                data = Data(data=data)\n            else:\n                data = Data(text=str(data))\n        elif not data:\n            data = Data(text=\"\")\n        if data:\n            if append:\n                self.append_state(name, data)\n            else:\n                self.update_state(name, data)\n        else:\n            self.status = \"No record provided.\"\n        self.status = data\n        self._set_successors_ids()\n        return data\n\n    def _set_successors_ids(self):\n        self._vertex.is_state = True\n        successors = self._vertex.graph.successor_map.get(self._vertex.id, [])\n        return successors + self._vertex.graph.activated_vertices\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "name": {
                    "type": "str",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": false,
                    "fileTypes": [],
                    "file_path": "",
                    "name": "name",
                    "display_name": "Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The name of the notification.",
                    "load_from_db": false,
                    "title_case": false,
                    "input_types": [
                        "Text"
                    ]
                }
            },
            "description": "A component to generate a notification to Get Notified component.",
            "icon": "Notify",
            "base_classes": [
                "Data"
            ],
            "display_name": "Notify",
            "documentation": "",
            "minimized": false,
            "custom_fields": {
                "name": null,
                "data": null,
                "append": null
            },
            "output_types": [
                "Data"
            ],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "data",
                    "hidden": null,
                    "display_name": "Data",
                    "method": null,
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": null,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [],
            "beta": true,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "Pass": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langflow.custom import Component\nfrom langflow.io import MessageInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass PassMessageComponent(Component):\n    display_name = \"Pass\"\n    description = \"Forwards the input message, unchanged.\"\n    name = \"Pass\"\n    icon = \"arrow-right\"\n\n    inputs = [\n        MessageInput(\n            name=\"input_message\",\n            display_name=\"Input Message\",\n            info=\"The message to be passed forward.\",\n            required=True,\n        ),\n        MessageInput(\n            name=\"ignored_message\",\n            display_name=\"Ignored Message\",\n            info=\"A second message to be ignored. Used as a workaround for continuity.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output Message\", name=\"output_message\", method=\"pass_message\"),\n    ]\n\n    def pass_message(self) -> Message:\n        self.status = self.input_message\n        return self.input_message\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "ignored_message": {
                    "trace_as_input": true,
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "ignored_message",
                    "value": "",
                    "display_name": "Ignored Message",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "A second message to be ignored. Used as a workaround for continuity.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageInput"
                },
                "input_message": {
                    "trace_as_input": true,
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "input_message",
                    "value": "",
                    "display_name": "Input Message",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The message to be passed forward.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageInput"
                }
            },
            "description": "Forwards the input message, unchanged.",
            "icon": "arrow-right",
            "base_classes": [
                "Message"
            ],
            "display_name": "Pass",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "output_message",
                    "display_name": "Output Message",
                    "method": "pass_message",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_message",
                "ignored_message"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "RunFlow": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from typing import Any\n\nfrom loguru import logger\n\nfrom langflow.base.tools.run_flow import RunFlowBaseComponent\nfrom langflow.helpers.flow import run_flow\nfrom langflow.schema import dotdict\n\n\nclass RunFlowComponent(RunFlowBaseComponent):\n    display_name = \"Run Flow\"\n    description = (\n        \"Creates a tool component from a Flow that takes all its inputs and runs it. \"\n        \" \\n **Select a Flow to use the tool mode**\"\n    )\n    beta = True\n    name = \"RunFlow\"\n    icon = \"Workflow\"\n\n    inputs = RunFlowBaseComponent._base_inputs\n    outputs = RunFlowBaseComponent._base_outputs\n\n    async def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"flow_name_selected\":\n            build_config[\"flow_name_selected\"][\"options\"] = await self.get_flow_names()\n            missing_keys = [key for key in self.default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n            if field_value is not None:\n                try:\n                    graph = await self.get_graph(field_value)\n                    build_config = self.update_build_config_from_graph(build_config, graph)\n                except Exception as e:\n                    msg = f\"Error building graph for flow {field_value}\"\n                    logger.exception(msg)\n                    raise RuntimeError(msg) from e\n        return build_config\n\n    async def run_flow_with_tweaks(self):\n        tweaks: dict = {}\n\n        flow_name_selected = self._attributes.get(\"flow_name_selected\")\n        parsed_flow_tweak_data = self._attributes.get(\"flow_tweak_data\", {})\n        if not isinstance(parsed_flow_tweak_data, dict):\n            parsed_flow_tweak_data = parsed_flow_tweak_data.dict()\n\n        if parsed_flow_tweak_data != {}:\n            for field in parsed_flow_tweak_data:\n                if \"~\" in field:\n                    [node, name] = field.split(\"~\")\n                    if node not in tweaks:\n                        tweaks[node] = {}\n                    tweaks[node][name] = parsed_flow_tweak_data[field]\n        else:\n            for field in self._attributes:\n                if field not in self.default_keys and \"~\" in field:\n                    [node, name] = field.split(\"~\")\n                    if node not in tweaks:\n                        tweaks[node] = {}\n                    tweaks[node][name] = self._attributes[field]\n\n        return await run_flow(\n            inputs=None,\n            output_type=\"all\",\n            flow_id=None,\n            flow_name=flow_name_selected,\n            tweaks=tweaks,\n            user_id=str(self.user_id),\n            session_id=self.graph.session_id or self.session_id,\n        )\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "flow_name_selected": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "flow_name_selected",
                    "display_name": "Flow Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The name of the flow to run.",
                    "real_time_refresh": true,
                    "refresh_button": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "session_id": {
                    "trace_as_input": true,
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": {
                        "text_key": "text",
                        "data": {
                            "text": "",
                            "files": [],
                            "timestamp": "2025-11-24 15:33:54 UTC"
                        },
                        "default_value": ""
                    },
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID to run the flow in.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageInput"
                }
            },
            "description": "Creates a tool component from a Flow that takes all its inputs and runs it.  \n **Select a Flow to use the tool mode**",
            "icon": "Workflow",
            "base_classes": [
                "Data",
                "DataFrame",
                "Message"
            ],
            "display_name": "Run Flow",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "flow_outputs_data",
                    "hidden": true,
                    "display_name": "Flow Data Output",
                    "method": "data_output",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "DataFrame"
                    ],
                    "selected": "DataFrame",
                    "name": "flow_outputs_dataframe",
                    "hidden": true,
                    "display_name": "Flow Dataframe Output",
                    "method": "dataframe_output",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "flow_outputs_message",
                    "display_name": "Flow Message Output",
                    "method": "message_output",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "flow_name_selected",
                "session_id"
            ],
            "beta": true,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "SubFlow": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from typing import Any\n\nfrom loguru import logger\n\nfrom langflow.base.flow_processing.utils import build_data_from_result_data\nfrom langflow.custom import Component\nfrom langflow.graph.graph.base import Graph\nfrom langflow.graph.vertex.base import Vertex\nfrom langflow.helpers.flow import get_flow_inputs\nfrom langflow.io import DropdownInput, Output\nfrom langflow.schema import Data, dotdict\n\n\nclass SubFlowComponent(Component):\n    display_name = \"Sub Flow [Deprecated]\"\n    description = \"Generates a Component from a Flow, with all of its inputs, and \"\n    name = \"SubFlow\"\n    legacy: bool = True\n    icon = \"Workflow\"\n\n    async def get_flow_names(self) -> list[str]:\n        flow_data = await self.alist_flows()\n        return [flow_data.data[\"name\"] for flow_data in flow_data]\n\n    async def get_flow(self, flow_name: str) -> Data | None:\n        flow_datas = await self.alist_flows()\n        for flow_data in flow_datas:\n            if flow_data.data[\"name\"] == flow_name:\n                return flow_data\n        return None\n\n    async def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"flow_name\":\n            build_config[\"flow_name\"][\"options\"] = await self.get_flow_names()\n\n        for key in list(build_config.keys()):\n            if key not in [x.name for x in self.inputs] + [\"code\", \"_type\", \"get_final_results_only\"]:\n                del build_config[key]\n        if field_value is not None and field_name == \"flow_name\":\n            try:\n                flow_data = await self.get_flow(field_value)\n            except Exception:  # noqa: BLE001\n                logger.exception(f\"Error getting flow {field_value}\")\n            else:\n                if not flow_data:\n                    msg = f\"Flow {field_value} not found.\"\n                    logger.error(msg)\n                else:\n                    try:\n                        graph = Graph.from_payload(flow_data.data[\"data\"])\n                        # Get all inputs from the graph\n                        inputs = get_flow_inputs(graph)\n                        # Add inputs to the build config\n                        build_config = self.add_inputs_to_build_config(inputs, build_config)\n                    except Exception:  # noqa: BLE001\n                        logger.exception(f\"Error building graph for flow {field_value}\")\n\n        return build_config\n\n    def add_inputs_to_build_config(self, inputs_vertex: list[Vertex], build_config: dotdict):\n        new_fields: list[dotdict] = []\n\n        for vertex in inputs_vertex:\n            new_vertex_inputs = []\n            field_template = vertex.data[\"node\"][\"template\"]\n            for inp in field_template:\n                if inp not in {\"code\", \"_type\"}:\n                    field_template[inp][\"display_name\"] = (\n                        vertex.display_name + \" - \" + field_template[inp][\"display_name\"]\n                    )\n                    field_template[inp][\"name\"] = vertex.id + \"|\" + inp\n                    new_vertex_inputs.append(field_template[inp])\n            new_fields += new_vertex_inputs\n        for field in new_fields:\n            build_config[field[\"name\"]] = field\n        return build_config\n\n    inputs = [\n        DropdownInput(\n            name=\"flow_name\",\n            display_name=\"Flow Name\",\n            info=\"The name of the flow to run.\",\n            options=[],\n            refresh_button=True,\n            real_time_refresh=True,\n        ),\n    ]\n\n    outputs = [Output(name=\"flow_outputs\", display_name=\"Flow Outputs\", method=\"generate_results\")]\n\n    async def generate_results(self) -> list[Data]:\n        tweaks: dict = {}\n        for field in self._attributes:\n            if field != \"flow_name\" and \"|\" in field:\n                [node, name] = field.split(\"|\")\n                if node not in tweaks:\n                    tweaks[node] = {}\n                tweaks[node][name] = self._attributes[field]\n        flow_name = self._attributes.get(\"flow_name\")\n        run_outputs = await self.run_flow(\n            tweaks=tweaks,\n            flow_name=flow_name,\n            output_type=\"all\",\n        )\n        data: list[Data] = []\n        if not run_outputs:\n            return data\n        run_output = run_outputs[0]\n\n        if run_output is not None:\n            for output in run_output.outputs:\n                if output:\n                    data.extend(build_data_from_result_data(output))\n        return data\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "flow_name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "flow_name",
                    "value": "",
                    "display_name": "Flow Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The name of the flow to run.",
                    "real_time_refresh": true,
                    "refresh_button": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                }
            },
            "description": "Generates a Component from a Flow, with all of its inputs, and ",
            "icon": "Workflow",
            "base_classes": [
                "Data"
            ],
            "display_name": "Sub Flow [Deprecated]",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "flow_outputs",
                    "display_name": "Flow Outputs",
                    "method": "generate_results",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "flow_name"
            ],
            "beta": false,
            "legacy": true,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        }
    },
    "models": {
        "AzureOpenAIModel": {
            "template": {
                "_type": "Component",
                "api_key": {
                    "load_from_db": true,
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "api_key",
                    "value": "",
                    "display_name": "API Key",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "password": true,
                    "type": "str",
                    "_input_type": "SecretStrInput"
                },
                "api_version": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "2024-10-01-preview",
                        "2024-09-01-preview",
                        "2024-08-01-preview",
                        "2024-07-01-preview",
                        "2024-06-01",
                        "2024-03-01-preview",
                        "2024-02-15-preview",
                        "2023-12-01-preview",
                        "2023-05-15"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "api_version",
                    "value": "2024-06-01",
                    "display_name": "API Version",
                    "advanced": false,
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "azure_deployment": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "azure_deployment",
                    "value": "",
                    "display_name": "Deployment Name",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "azure_endpoint": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "azure_endpoint",
                    "value": "",
                    "display_name": "Azure Endpoint",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Your Azure endpoint, including the resource. Example: `https://example-resource.azure.openai.com/`",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langchain_openai import AzureChatOpenAI\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import MessageTextInput\nfrom langflow.io import DropdownInput, IntInput, SecretStrInput, SliderInput\n\n\nclass AzureChatOpenAIComponent(LCModelComponent):\n    display_name: str = \"Azure OpenAI\"\n    description: str = \"Generate text using Azure OpenAI LLMs.\"\n    documentation: str = \"https://python.langchain.com/docs/integrations/llms/azure_openai\"\n    beta = False\n    icon = \"Azure\"\n    name = \"AzureOpenAIModel\"\n\n    AZURE_OPENAI_API_VERSIONS = [\n        \"2024-06-01\",\n        \"2024-07-01-preview\",\n        \"2024-08-01-preview\",\n        \"2024-09-01-preview\",\n        \"2024-10-01-preview\",\n        \"2023-05-15\",\n        \"2023-12-01-preview\",\n        \"2024-02-15-preview\",\n        \"2024-03-01-preview\",\n    ]\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        MessageTextInput(\n            name=\"azure_endpoint\",\n            display_name=\"Azure Endpoint\",\n            info=\"Your Azure endpoint, including the resource. Example: `https://example-resource.azure.openai.com/`\",\n            required=True,\n        ),\n        MessageTextInput(name=\"azure_deployment\", display_name=\"Deployment Name\", required=True),\n        SecretStrInput(name=\"api_key\", display_name=\"API Key\", required=True),\n        DropdownInput(\n            name=\"api_version\",\n            display_name=\"API Version\",\n            options=sorted(AZURE_OPENAI_API_VERSIONS, reverse=True),\n            value=next(\n                (\n                    version\n                    for version in sorted(AZURE_OPENAI_API_VERSIONS, reverse=True)\n                    if not version.endswith(\"-preview\")\n                ),\n                AZURE_OPENAI_API_VERSIONS[0],\n            ),\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.7,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n            info=\"Controls randomness. Lower values are more deterministic, higher values are more creative.\",\n        ),\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        azure_endpoint = self.azure_endpoint\n        azure_deployment = self.azure_deployment\n        api_version = self.api_version\n        api_key = self.api_key\n        temperature = self.temperature\n        max_tokens = self.max_tokens\n        stream = self.stream\n\n        try:\n            output = AzureChatOpenAI(\n                azure_endpoint=azure_endpoint,\n                azure_deployment=azure_deployment,\n                api_version=api_version,\n                api_key=api_key,\n                temperature=temperature,\n                max_tokens=max_tokens or None,\n                streaming=stream,\n            )\n        except Exception as e:\n            msg = f\"Could not connect to AzureOpenAI API: {e}\"\n            raise ValueError(msg) from e\n\n        return output\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "input_value": {
                    "trace_as_input": true,
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "",
                    "display_name": "Input",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageInput"
                },
                "max_tokens": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_tokens",
                    "value": "",
                    "display_name": "Max Tokens",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "stream": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "stream",
                    "value": false,
                    "display_name": "Stream",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Stream the response from the model. Streaming works only in Chat.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "system_message": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "system_message",
                    "value": "",
                    "display_name": "System Message",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "System message to pass to the model.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "temperature": {
                    "tool_mode": false,
                    "min_label": "",
                    "max_label": "",
                    "min_label_icon": "",
                    "max_label_icon": "",
                    "slider_buttons": false,
                    "slider_buttons_options": [],
                    "slider_input": false,
                    "range_spec": {
                        "step_type": "float",
                        "min": 0,
                        "max": 2,
                        "step": 0.01
                    },
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "temperature",
                    "value": 0.7,
                    "display_name": "Temperature",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                    "title_case": false,
                    "type": "slider",
                    "_input_type": "SliderInput"
                }
            },
            "description": "Generate text using Azure OpenAI LLMs.",
            "icon": "Azure",
            "base_classes": [
                "LanguageModel",
                "Message"
            ],
            "display_name": "Azure OpenAI",
            "documentation": "https://python.langchain.com/docs/integrations/llms/azure_openai",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "text_output",
                    "display_name": "Message",
                    "method": "text_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "LanguageModel"
                    ],
                    "selected": "LanguageModel",
                    "name": "model_output",
                    "display_name": "Language Model",
                    "method": "build_model",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [
                        "api_key",
                        "azure_deployment",
                        "azure_endpoint"
                    ],
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_value",
                "system_message",
                "stream",
                "azure_endpoint",
                "azure_deployment",
                "api_key",
                "api_version",
                "temperature",
                "max_tokens"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "DeepSeekModelComponent": {
            "template": {
                "_type": "Component",
                "api_base": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "api_base",
                    "value": "https://api.deepseek.com",
                    "display_name": "DeepSeek API Base",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Base URL for API requests. Defaults to https://api.deepseek.com",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "api_key": {
                    "load_from_db": true,
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "api_key",
                    "value": "",
                    "display_name": "DeepSeek API Key",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The DeepSeek API Key",
                    "title_case": false,
                    "password": true,
                    "type": "str",
                    "_input_type": "SecretStrInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "import requests\nfrom pydantic.v1 import SecretStr\nfrom typing_extensions import override\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import BoolInput, DictInput, DropdownInput, IntInput, SecretStrInput, SliderInput, StrInput\n\nDEEPSEEK_MODELS = [\"deepseek-chat\"]\n\n\nclass DeepSeekModelComponent(LCModelComponent):\n    display_name = \"DeepSeek\"\n    description = \"Generate text using DeepSeek LLMs.\"\n    icon = \"DeepSeek\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"Maximum number of tokens to generate. Set to 0 for unlimited.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            info=\"DeepSeek model to use\",\n            options=DEEPSEEK_MODELS,\n            value=\"deepseek-chat\",\n            refresh_button=True,\n        ),\n        StrInput(\n            name=\"api_base\",\n            display_name=\"DeepSeek API Base\",\n            advanced=True,\n            info=\"Base URL for API requests. Defaults to https://api.deepseek.com\",\n            value=\"https://api.deepseek.com\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"DeepSeek API Key\",\n            info=\"The DeepSeek API Key\",\n            advanced=False,\n            required=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            info=\"Controls randomness in responses\",\n            value=1.0,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n        ),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n    ]\n\n    def get_models(self) -> list[str]:\n        if not self.api_key:\n            return DEEPSEEK_MODELS\n\n        url = f\"{self.api_base}/models\"\n        headers = {\"Authorization\": f\"Bearer {self.api_key}\", \"Accept\": \"application/json\"}\n\n        try:\n            response = requests.get(url, headers=headers, timeout=10)\n            response.raise_for_status()\n            model_list = response.json()\n            return [model[\"id\"] for model in model_list.get(\"data\", [])]\n        except requests.RequestException as e:\n            self.status = f\"Error fetching models: {e}\"\n            return DEEPSEEK_MODELS\n\n    @override\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None):\n        if field_name in {\"api_key\", \"api_base\", \"model_name\"}:\n            models = self.get_models()\n            build_config[\"model_name\"][\"options\"] = models\n        return build_config\n\n    def build_model(self) -> LanguageModel:\n        try:\n            from langchain_openai import ChatOpenAI\n        except ImportError as e:\n            msg = \"langchain-openai not installed. Please install with `pip install langchain-openai`\"\n            raise ImportError(msg) from e\n\n        api_key = SecretStr(self.api_key).get_secret_value() if self.api_key else None\n        output = ChatOpenAI(\n            model=self.model_name,\n            temperature=self.temperature if self.temperature is not None else 0.1,\n            max_tokens=self.max_tokens or None,\n            model_kwargs=self.model_kwargs or {},\n            base_url=self.api_base,\n            api_key=api_key,\n            streaming=self.stream if hasattr(self, \"stream\") else False,\n            seed=self.seed,\n        )\n\n        if self.json_mode:\n            output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get message from DeepSeek API exception.\"\"\"\n        try:\n            from openai import BadRequestError\n\n            if isinstance(e, BadRequestError):\n                message = e.body.get(\"message\")\n                if message:\n                    return message\n        except ImportError:\n            pass\n        return None\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "input_value": {
                    "trace_as_input": true,
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "",
                    "display_name": "Input",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageInput"
                },
                "json_mode": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "json_mode",
                    "value": false,
                    "display_name": "JSON Mode",
                    "advanced": true,
                    "dynamic": false,
                    "info": "If True, it will output JSON regardless of passing a schema.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "max_tokens": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "range_spec": {
                        "step_type": "float",
                        "min": 0,
                        "max": 128000,
                        "step": 0.1
                    },
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_tokens",
                    "value": "",
                    "display_name": "Max Tokens",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Maximum number of tokens to generate. Set to 0 for unlimited.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "model_kwargs": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "model_kwargs",
                    "value": {},
                    "display_name": "Model Kwargs",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Additional keyword arguments to pass to the model.",
                    "title_case": false,
                    "type": "dict",
                    "_input_type": "DictInput"
                },
                "model_name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "deepseek-chat"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "model_name",
                    "value": "deepseek-chat",
                    "display_name": "Model Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "DeepSeek model to use",
                    "refresh_button": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "seed": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "seed",
                    "value": 1,
                    "display_name": "Seed",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The seed controls the reproducibility of the job.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "stream": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "stream",
                    "value": false,
                    "display_name": "Stream",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Stream the response from the model. Streaming works only in Chat.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "system_message": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "system_message",
                    "value": "",
                    "display_name": "System Message",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "System message to pass to the model.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "temperature": {
                    "tool_mode": false,
                    "min_label": "",
                    "max_label": "",
                    "min_label_icon": "",
                    "max_label_icon": "",
                    "slider_buttons": false,
                    "slider_buttons_options": [],
                    "slider_input": false,
                    "range_spec": {
                        "step_type": "float",
                        "min": 0,
                        "max": 2,
                        "step": 0.01
                    },
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "temperature",
                    "value": 1,
                    "display_name": "Temperature",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Controls randomness in responses",
                    "title_case": false,
                    "type": "slider",
                    "_input_type": "SliderInput"
                }
            },
            "description": "Generate text using DeepSeek LLMs.",
            "icon": "DeepSeek",
            "base_classes": [
                "LanguageModel",
                "Message"
            ],
            "display_name": "DeepSeek",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "text_output",
                    "display_name": "Message",
                    "method": "text_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "LanguageModel"
                    ],
                    "selected": "LanguageModel",
                    "name": "model_output",
                    "display_name": "Language Model",
                    "method": "build_model",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [
                        "api_key"
                    ],
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_value",
                "system_message",
                "stream",
                "max_tokens",
                "model_kwargs",
                "json_mode",
                "model_name",
                "api_base",
                "api_key",
                "temperature",
                "seed"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "OpenAIModel": {
            "template": {
                "_type": "Component",
                "api_key": {
                    "load_from_db": true,
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "api_key",
                    "value": "OPENAI_API_KEY",
                    "display_name": "OpenAI API Key",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The OpenAI API Key to use for the OpenAI model.",
                    "title_case": false,
                    "password": true,
                    "type": "str",
                    "_input_type": "SecretStrInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import OPENAI_MODEL_NAMES\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import BoolInput, DictInput, DropdownInput, IntInput, SecretStrInput, SliderInput, StrInput\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        StrInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            info=\"The name of the OpenAI model to use (e.g., 'gpt-4').\",\n            value=\"gpt-4o-mini\"\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n            required=True,\n        ),\n        SliderInput(\n            name=\"temperature\", display_name=\"Temperature\", value=0.1, range_spec=RangeSpec(min=0, max=1, step=0.01)\n        ),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        IntInput(\n            name=\"max_retries\",\n            display_name=\"Max Retries\",\n            info=\"The maximum number of retries to make when generating.\",\n            advanced=True,\n            value=5,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"The timeout for requests to OpenAI completion API.\",\n            advanced=True,\n            value=700,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        openai_api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        model_kwargs = self.model_kwargs or {}\n        openai_api_base = self.openai_api_base or \"https://api.openai.com/v1\"\n        json_mode = self.json_mode\n        seed = self.seed\n        max_retries = self.max_retries\n        timeout = self.timeout\n\n        # Gemini models do not support the seed parameter\n        if \"gemini\" in model_name.lower():\n            seed = None\n\n        api_key = SecretStr(openai_api_key).get_secret_value() if openai_api_key else None\n        output = ChatOpenAI(\n            max_tokens=max_tokens or None,\n            model_kwargs=model_kwargs,\n            model=model_name,\n            base_url=openai_api_base,\n            api_key=api_key,\n            temperature=temperature if temperature is not None else 0.1,\n            seed=seed,\n            max_retries=max_retries,\n            request_timeout=timeout,\n        )\n        if json_mode:\n            output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "input_value": {
                    "trace_as_input": true,
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "",
                    "display_name": "Input",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageInput"
                },
                "json_mode": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "json_mode",
                    "value": false,
                    "display_name": "JSON Mode",
                    "advanced": true,
                    "dynamic": false,
                    "info": "If True, it will output JSON regardless of passing a schema.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "max_retries": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_retries",
                    "value": 5,
                    "display_name": "Max Retries",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The maximum number of retries to make when generating.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "max_tokens": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "range_spec": {
                        "step_type": "float",
                        "min": 0,
                        "max": 128000,
                        "step": 0.1
                    },
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_tokens",
                    "value": "",
                    "display_name": "Max Tokens",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "model_kwargs": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "model_kwargs",
                    "value": {},
                    "display_name": "Model Kwargs",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Additional keyword arguments to pass to the model.",
                    "title_case": false,
                    "type": "dict",
                    "_input_type": "DictInput"
                },
                "model_name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "model_name",
                    "value": "gpt-4o-mini",
                    "display_name": "Model Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The name of the OpenAI model to use (e.g., 'gpt-4').",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "openai_api_base": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "openai_api_base",
                    "value": "",
                    "display_name": "OpenAI API Base",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "seed": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "seed",
                    "value": 1,
                    "display_name": "Seed",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The seed controls the reproducibility of the job.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "stream": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "stream",
                    "value": false,
                    "display_name": "Stream",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Stream the response from the model. Streaming works only in Chat.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "system_message": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "system_message",
                    "value": "",
                    "display_name": "System Message",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "System message to pass to the model.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "temperature": {
                    "tool_mode": false,
                    "min_label": "",
                    "max_label": "",
                    "min_label_icon": "",
                    "max_label_icon": "",
                    "slider_buttons": false,
                    "slider_buttons_options": [],
                    "slider_input": false,
                    "range_spec": {
                        "step_type": "float",
                        "min": 0,
                        "max": 1,
                        "step": 0.01
                    },
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "temperature",
                    "value": 0.1,
                    "display_name": "Temperature",
                    "advanced": false,
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "slider",
                    "_input_type": "SliderInput"
                },
                "timeout": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "timeout",
                    "value": 700,
                    "display_name": "Timeout",
                    "advanced": true,
                    "dynamic": false,
                    "info": "The timeout for requests to OpenAI completion API.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                }
            },
            "description": "Generates text using OpenAI LLMs.",
            "icon": "OpenAI",
            "base_classes": [
                "LanguageModel",
                "Message"
            ],
            "display_name": "OpenAI",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "text_output",
                    "display_name": "Message",
                    "method": "text_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "LanguageModel"
                    ],
                    "selected": "LanguageModel",
                    "name": "model_output",
                    "display_name": "Language Model",
                    "method": "build_model",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [
                        "api_key"
                    ],
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_value",
                "system_message",
                "stream",
                "max_tokens",
                "model_kwargs",
                "json_mode",
                "model_name",
                "openai_api_base",
                "api_key",
                "temperature",
                "seed",
                "max_retries",
                "timeout"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "OpenRouterComponent": {
            "template": {
                "_type": "Component",
                "api_key": {
                    "load_from_db": true,
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "api_key",
                    "value": "",
                    "display_name": "OpenRouter API Key",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Your OpenRouter API key",
                    "title_case": false,
                    "password": true,
                    "type": "str",
                    "_input_type": "SecretStrInput"
                },
                "app_name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "app_name",
                    "value": "",
                    "display_name": "App Name",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Your app name for OpenRouter rankings",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from collections import defaultdict\nfrom typing import Any\n\nimport httpx\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import (\n    DropdownInput,\n    IntInput,\n    SecretStrInput,\n    SliderInput,\n    StrInput,\n)\n\n\nclass OpenRouterComponent(LCModelComponent):\n    \"\"\"OpenRouter API component for language models.\"\"\"\n\n    display_name = \"OpenRouter\"\n    description = (\n        \"OpenRouter provides unified access to multiple AI models from different providers through a single API.\"\n    )\n    icon = \"OpenRouter\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        SecretStrInput(\n            name=\"api_key\", display_name=\"OpenRouter API Key\", required=True, info=\"Your OpenRouter API key\"\n        ),\n        StrInput(\n            name=\"site_url\",\n            display_name=\"Site URL\",\n            info=\"Your site URL for OpenRouter rankings\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"app_name\",\n            display_name=\"App Name\",\n            info=\"Your app name for OpenRouter rankings\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"provider\",\n            display_name=\"Provider\",\n            info=\"The AI model provider\",\n            options=[\"Loading providers...\"],\n            value=\"Loading providers...\",\n            real_time_refresh=True,\n            required=True,\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            info=\"The model to use for chat completion\",\n            options=[\"Select a provider first\"],\n            value=\"Select a provider first\",\n            real_time_refresh=True,\n            required=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.7,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n            info=\"Controls randomness. Lower values are more deterministic, higher values are more creative.\",\n        ),\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            info=\"Maximum number of tokens to generate\",\n            advanced=True,\n        ),\n    ]\n\n    def fetch_models(self) -> dict[str, list]:\n        \"\"\"Fetch available models from OpenRouter API and organize them by provider.\"\"\"\n        url = \"https://openrouter.ai/api/v1/models\"\n\n        try:\n            with httpx.Client() as client:\n                response = client.get(url)\n                response.raise_for_status()\n\n                models_data = response.json().get(\"data\", [])\n                provider_models = defaultdict(list)\n\n                for model in models_data:\n                    model_id = model.get(\"id\", \"\")\n                    if \"/\" in model_id:\n                        provider = model_id.split(\"/\")[0].title()\n                        provider_models[provider].append(\n                            {\n                                \"id\": model_id,\n                                \"name\": model.get(\"name\", \"\"),\n                                \"description\": model.get(\"description\", \"\"),\n                                \"context_length\": model.get(\"context_length\", 0),\n                            }\n                        )\n\n                return dict(provider_models)\n\n        except httpx.HTTPError as e:\n            self.log(f\"Error fetching models: {e!s}\")\n            return {\"Error\": [{\"id\": \"error\", \"name\": f\"Error fetching models: {e!s}\"}]}\n\n    def build_model(self) -> LanguageModel:\n        \"\"\"Build and return the OpenRouter language model.\"\"\"\n        model_not_selected = \"Please select a model\"\n        api_key_required = \"API key is required\"\n\n        if not self.model_name or self.model_name == \"Select a provider first\":\n            raise ValueError(model_not_selected)\n\n        if not self.api_key:\n            raise ValueError(api_key_required)\n\n        api_key = SecretStr(self.api_key).get_secret_value()\n\n        # Build base configuration\n        kwargs: dict[str, Any] = {\n            \"model\": self.model_name,\n            \"openai_api_key\": api_key,\n            \"openai_api_base\": \"https://openrouter.ai/api/v1\",\n            \"temperature\": self.temperature if self.temperature is not None else 0.7,\n        }\n\n        # Add optional parameters\n        if self.max_tokens:\n            kwargs[\"max_tokens\"] = self.max_tokens\n\n        headers = {}\n        if self.site_url:\n            headers[\"HTTP-Referer\"] = self.site_url\n        if self.app_name:\n            headers[\"X-Title\"] = self.app_name\n\n        if headers:\n            kwargs[\"default_headers\"] = headers\n\n        try:\n            return ChatOpenAI(**kwargs)\n        except (ValueError, httpx.HTTPError) as err:\n            error_msg = f\"Failed to build model: {err!s}\"\n            self.log(error_msg)\n            raise ValueError(error_msg) from err\n\n    def _get_exception_message(self, e: Exception) -> str | None:\n        \"\"\"Get a message from an OpenRouter exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str | None: The message from the exception, or None if no specific message can be extracted.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n\n            if isinstance(e, BadRequestError):\n                message = e.body.get(\"message\")\n                if message:\n                    return message\n        except ImportError:\n            pass\n        return None\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        \"\"\"Update build configuration based on field updates.\"\"\"\n        try:\n            if field_name is None or field_name == \"provider\":\n                provider_models = self.fetch_models()\n                build_config[\"provider\"][\"options\"] = sorted(provider_models.keys())\n                if build_config[\"provider\"][\"value\"] not in provider_models:\n                    build_config[\"provider\"][\"value\"] = build_config[\"provider\"][\"options\"][0]\n\n            if field_name == \"provider\" and field_value in self.fetch_models():\n                provider_models = self.fetch_models()\n                models = provider_models[field_value]\n\n                build_config[\"model_name\"][\"options\"] = [model[\"id\"] for model in models]\n                if models:\n                    build_config[\"model_name\"][\"value\"] = models[0][\"id\"]\n\n                tooltips = {\n                    model[\"id\"]: (f\"{model['name']}\\nContext Length: {model['context_length']}\\n{model['description']}\")\n                    for model in models\n                }\n                build_config[\"model_name\"][\"tooltips\"] = tooltips\n\n        except httpx.HTTPError as e:\n            self.log(f\"Error updating build config: {e!s}\")\n            build_config[\"provider\"][\"options\"] = [\"Error loading providers\"]\n            build_config[\"provider\"][\"value\"] = \"Error loading providers\"\n            build_config[\"model_name\"][\"options\"] = [\"Error loading models\"]\n            build_config[\"model_name\"][\"value\"] = \"Error loading models\"\n\n        return build_config\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "input_value": {
                    "trace_as_input": true,
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "",
                    "display_name": "Input",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageInput"
                },
                "max_tokens": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "max_tokens",
                    "value": "",
                    "display_name": "Max Tokens",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Maximum number of tokens to generate",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "model_name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "Select a provider first"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "model_name",
                    "value": "Select a provider first",
                    "display_name": "Model",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The model to use for chat completion",
                    "real_time_refresh": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "provider": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "Loading providers..."
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "provider",
                    "value": "Loading providers...",
                    "display_name": "Provider",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The AI model provider",
                    "real_time_refresh": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "site_url": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "site_url",
                    "value": "",
                    "display_name": "Site URL",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Your site URL for OpenRouter rankings",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "stream": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "stream",
                    "value": false,
                    "display_name": "Stream",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Stream the response from the model. Streaming works only in Chat.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "system_message": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "system_message",
                    "value": "",
                    "display_name": "System Message",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "System message to pass to the model.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "temperature": {
                    "tool_mode": false,
                    "min_label": "",
                    "max_label": "",
                    "min_label_icon": "",
                    "max_label_icon": "",
                    "slider_buttons": false,
                    "slider_buttons_options": [],
                    "slider_input": false,
                    "range_spec": {
                        "step_type": "float",
                        "min": 0,
                        "max": 2,
                        "step": 0.01
                    },
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "temperature",
                    "value": 0.7,
                    "display_name": "Temperature",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                    "title_case": false,
                    "type": "slider",
                    "_input_type": "SliderInput"
                }
            },
            "description": "OpenRouter provides unified access to multiple AI models from different providers through a single API.",
            "icon": "OpenRouter",
            "base_classes": [
                "LanguageModel",
                "Message"
            ],
            "display_name": "OpenRouter",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "text_output",
                    "display_name": "Message",
                    "method": "text_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "LanguageModel"
                    ],
                    "selected": "LanguageModel",
                    "name": "model_output",
                    "display_name": "Language Model",
                    "method": "build_model",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [
                        "api_key",
                        "model_name"
                    ],
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_value",
                "system_message",
                "stream",
                "api_key",
                "site_url",
                "app_name",
                "provider",
                "model_name",
                "temperature",
                "max_tokens"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        }
    },
    "outputs": {
        "ChatOutput": {
            "template": {
                "_type": "Component",
                "input_value": {
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "",
                    "display_name": "Text",
                    "advanced": false,
                    "input_types": [
                        "Data",
                        "DataFrame",
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Message to be passed as output.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "background_color": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "background_color",
                    "value": "",
                    "display_name": "Background Color",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The background color of the icon.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "chat_icon": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "chat_icon",
                    "value": "",
                    "display_name": "Icon",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The icon of the message.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "clean_data": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "clean_data",
                    "value": true,
                    "display_name": "Basic Clean Data",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Whether to clean the data",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from collections.abc import Generator\nfrom typing import Any\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                if data.get_text() is None:\n                    msg = \"Empty Data object\"\n                    raise ValueError(msg)\n                return data.get_text()\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return (\n                    data.replace(r\"\\|\", r\"\\\\|\", regex=True)\n                    .applymap(lambda x: (str(x).replace(\"\\n\", \"<br/>\") if isinstance(x, str) else x))\n                    .to_markdown(index=False)\n                )\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return self._safe_convert(self.input_value)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "data_template": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "data_template",
                    "value": "{text}",
                    "display_name": "Data Template",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "sender": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [
                        "Machine",
                        "User"
                    ],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender",
                    "value": "Machine",
                    "display_name": "Sender Type",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Type of sender.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender_name": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender_name",
                    "value": "AI",
                    "display_name": "Sender Name",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Name of the sender.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "session_id": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": "",
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "should_store_message": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "should_store_message",
                    "value": true,
                    "display_name": "Store Messages",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Store the message in the history.",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "text_color": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "text_color",
                    "value": "",
                    "display_name": "Text Color",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The text color of the name",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                }
            },
            "description": "Display a chat message in the Playground.",
            "icon": "MessagesSquare",
            "base_classes": [
                "Message"
            ],
            "display_name": "Chat Output",
            "documentation": "",
            "minimized": true,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "message",
                    "display_name": "Message",
                    "method": "message_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_value",
                "should_store_message",
                "sender",
                "sender_name",
                "session_id",
                "data_template",
                "background_color",
                "chat_icon",
                "text_color",
                "clean_data"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "TextOutput": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextOutputComponent(TextComponent):\n    display_name = \"Text Output\"\n    description = \"Display a text output in the Playground.\"\n    icon = \"type\"\n    name = \"TextOutput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as output.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n        )\n        self.status = self.input_value\n        return message\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "input_value": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "",
                    "display_name": "Text",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Text to be passed as output.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                }
            },
            "description": "Display a text output in the Playground.",
            "icon": "type",
            "base_classes": [
                "Message"
            ],
            "display_name": "Text Output",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "text",
                    "display_name": "Message",
                    "method": "text_response",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        }
    },
    "prompts": {
        "Prompt": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "template": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "template",
                    "value": "",
                    "display_name": "Template",
                    "advanced": false,
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "prompt",
                    "_input_type": "PromptInput"
                },
                "tool_placeholder": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "tool_placeholder",
                    "value": "",
                    "display_name": "Tool Placeholder",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "A placeholder input for tool mode.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                }
            },
            "description": "Create a prompt template with dynamic variables.",
            "icon": "prompts",
            "base_classes": [
                "Message"
            ],
            "display_name": "Prompt",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "prompt",
                    "display_name": "Prompt Message",
                    "method": "build_prompt",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "template",
                "tool_placeholder"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        }
    },
    "prototypes": {
        "PythonFunction": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from collections.abc import Callable\n\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.custom.utils import get_function\nfrom langflow.io import CodeInput, Output\nfrom langflow.schema import Data, dotdict\nfrom langflow.schema.message import Message\n\n\nclass PythonFunctionComponent(Component):\n    display_name = \"Python Function\"\n    description = \"Define and execute a Python function that returns a Data object or a Message.\"\n    icon = \"Python\"\n    name = \"PythonFunction\"\n    legacy = True\n\n    inputs = [\n        CodeInput(\n            name=\"function_code\",\n            display_name=\"Function Code\",\n            info=\"The code for the function.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            name=\"function_output\",\n            display_name=\"Function Callable\",\n            method=\"get_function_callable\",\n        ),\n        Output(\n            name=\"function_output_data\",\n            display_name=\"Function Output (Data)\",\n            method=\"execute_function_data\",\n        ),\n        Output(\n            name=\"function_output_str\",\n            display_name=\"Function Output (Message)\",\n            method=\"execute_function_message\",\n        ),\n    ]\n\n    def get_function_callable(self) -> Callable:\n        function_code = self.function_code\n        self.status = function_code\n        return get_function(function_code)\n\n    def execute_function(self) -> list[dotdict | str] | dotdict | str:\n        function_code = self.function_code\n\n        if not function_code:\n            return \"No function code provided.\"\n\n        try:\n            func = get_function(function_code)\n            return func()\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error executing function\")\n            return f\"Error executing function: {e}\"\n\n    def execute_function_data(self) -> list[Data]:\n        results = self.execute_function()\n        results = results if isinstance(results, list) else [results]\n        return [(Data(text=x) if isinstance(x, str) else Data(**x)) for x in results]\n\n    def execute_function_message(self) -> Message:\n        results = self.execute_function()\n        results = results if isinstance(results, list) else [results]\n        results_list = [str(x) for x in results]\n        results_str = \"\\n\".join(results_list)\n        return Message(text=results_str)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "function_code": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "function_code",
                    "value": "",
                    "display_name": "Function Code",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The code for the function.",
                    "title_case": false,
                    "type": "code",
                    "_input_type": "CodeInput"
                }
            },
            "description": "Define and execute a Python function that returns a Data object or a Message.",
            "icon": "Python",
            "base_classes": [
                "Callable",
                "Data",
                "Message"
            ],
            "display_name": "Python Function",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Callable"
                    ],
                    "selected": "Callable",
                    "name": "function_output",
                    "display_name": "Function Callable",
                    "method": "get_function_callable",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "function_output_data",
                    "display_name": "Function Output (Data)",
                    "method": "execute_function_data",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "function_output_str",
                    "display_name": "Function Output (Message)",
                    "method": "execute_function_message",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "function_code"
            ],
            "beta": false,
            "legacy": true,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        }
    },
    "tools": {
        "MCPSse": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "# from langflow.field_typing import Data\nfrom contextlib import AsyncExitStack\n\nimport httpx\nfrom mcp import ClientSession, types\nfrom mcp.client.sse import sse_client\n\nfrom langflow.base.mcp.util import create_tool_coroutine, create_tool_func\nfrom langflow.components.tools.mcp_stdio import create_input_schema_from_json_schema\nfrom langflow.custom import Component\nfrom langflow.field_typing import Tool\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.utils.async_helpers import timeout_context\n\n# Define constant for status code\nHTTP_TEMPORARY_REDIRECT = 307\n\n\nclass MCPSseClient:\n    def __init__(self):\n        # Initialize session and client objects\n        self.write = None\n        self.sse = None\n        self.session: ClientSession | None = None\n        self.exit_stack = AsyncExitStack()\n\n    async def pre_check_redirect(self, url: str):\n        \"\"\"Check if the URL responds with a 307 Redirect.\"\"\"\n        async with httpx.AsyncClient(follow_redirects=False) as client:\n            response = await client.request(\"HEAD\", url)\n            if response.status_code == HTTP_TEMPORARY_REDIRECT:\n                return response.headers.get(\"Location\")  # Return the redirect URL\n        return url  # Return the original URL if no redirect\n\n    async def connect_to_server(\n        self, url: str, headers: dict[str, str] | None, timeout_seconds: int = 500, sse_read_timeout_seconds: int = 500\n    ):\n        if headers is None:\n            headers = {}\n        url = await self.pre_check_redirect(url)\n\n        async with timeout_context(timeout_seconds):\n            sse_transport = await self.exit_stack.enter_async_context(\n                sse_client(url, headers, timeout_seconds, sse_read_timeout_seconds)\n            )\n            self.sse, self.write = sse_transport\n            self.session = await self.exit_stack.enter_async_context(ClientSession(self.sse, self.write))\n\n            await self.session.initialize()\n\n            # List available tools\n            response = await self.session.list_tools()\n            return response.tools\n\n\nclass MCPSse(Component):\n    client = MCPSseClient()\n    tools = types.ListToolsResult\n    tool_names = [str]\n    display_name = \"MCP Tools (SSE)\"\n    description = \"Connects to an MCP server over SSE and exposes it's tools as tools to be used by an Agent.\"\n    icon = \"code\"\n    name = \"MCPSse\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"url\",\n            display_name=\"mcp sse url\",\n            info=\"sse url\",\n            value=\"http://localhost:7860/api/v1/mcp/sse\",\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Tools\", name=\"tools\", method=\"build_output\"),\n    ]\n\n    async def build_output(self) -> list[Tool]:\n        if self.client.session is None:\n            self.tools = await self.client.connect_to_server(self.url, {})\n\n        tool_list = []\n\n        for tool in self.tools:\n            args_schema = create_input_schema_from_json_schema(tool.inputSchema)\n            tool_list.append(\n                Tool(\n                    name=tool.name,  # maybe format this\n                    description=tool.description,\n                    coroutine=create_tool_coroutine(tool.name, args_schema, self.client.session),\n                    func=create_tool_func(tool.name, self.client.session),\n                )\n            )\n\n        self.tool_names = [tool.name for tool in self.tools]\n        return tool_list\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "url": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "url",
                    "value": "http://localhost:7860/api/v1/mcp/sse",
                    "display_name": "mcp sse url",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "sse url",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                }
            },
            "description": "Connects to an MCP server over SSE and exposes it's tools as tools to be used by an Agent.",
            "icon": "code",
            "base_classes": [
                "Tool"
            ],
            "display_name": "MCP Tools (SSE)",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Tool"
                    ],
                    "selected": "Tool",
                    "name": "tools",
                    "display_name": "Tools",
                    "method": "build_output",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "url"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "MCPStdio": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "# from langflow.field_typing import Data\nimport os\nfrom contextlib import AsyncExitStack\nfrom typing import Any\n\nfrom mcp import ClientSession, StdioServerParameters, types\nfrom mcp.client.stdio import stdio_client\nfrom pydantic import BaseModel, Field, create_model\n\nfrom langflow.base.mcp.util import create_tool_coroutine, create_tool_func\nfrom langflow.custom import Component\nfrom langflow.field_typing import Tool\nfrom langflow.io import MessageTextInput, Output\n\n\nclass MCPStdioClient:\n    def __init__(self):\n        # Initialize session and client objects\n        self.session: ClientSession | None = None\n        self.exit_stack = AsyncExitStack()\n\n    async def connect_to_server(self, command_str: str):\n        command = command_str.split(\" \")\n        server_params = StdioServerParameters(\n            command=command[0], args=command[1:], env={\"DEBUG\": \"true\", \"PATH\": os.environ[\"PATH\"]}\n        )\n\n        stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))\n        self.stdio, self.write = stdio_transport\n        self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))\n\n        await self.session.initialize()\n\n        # List available tools\n        response = await self.session.list_tools()\n        return response.tools\n\n\ndef create_input_schema_from_json_schema(schema: dict[str, Any]) -> type[BaseModel]:\n    \"\"\"Converts a JSON schema into a Pydantic model dynamically.\n\n    :param schema: The JSON schema as a dictionary.\n    :return: A Pydantic model class.\n    \"\"\"\n    if schema.get(\"type\") != \"object\":\n        msg = \"JSON schema must be of type 'object' at the root level.\"\n        raise ValueError(msg)\n\n    fields = {}\n    properties = schema.get(\"properties\", {})\n    required_fields = set(schema.get(\"required\", []))\n\n    for field_name, field_def in properties.items():\n        # Extract type\n        field_type_str = field_def.get(\"type\", \"str\")  # Default to string type if not specified\n        field_type = {\n            \"string\": str,\n            \"str\": str,\n            \"integer\": int,\n            \"int\": int,\n            \"number\": float,\n            \"boolean\": bool,\n            \"array\": list,\n            \"object\": dict,\n        }.get(field_type_str, Any)\n\n        # Extract description and default if present\n        field_metadata = {\"description\": field_def.get(\"description\", \"\")}\n        if field_name not in required_fields:\n            field_metadata[\"default\"] = field_def.get(\"default\", None)\n\n        # Create Pydantic field\n        fields[field_name] = (field_type, Field(**field_metadata))\n\n    # Dynamically create the model\n    return create_model(\"InputSchema\", **fields)\n\n\nclass MCPStdio(Component):\n    client = MCPStdioClient()\n    tools = types.ListToolsResult\n    tool_names = [str]\n    display_name = \"MCP Tools (stdio)\"\n    description = (\n        \"Connects to an MCP server over stdio and exposes it's tools as tools to be used by an Agent.\"\n    )\n    icon = \"code\"\n    name = \"MCPStdio\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"command\",\n            display_name=\"mcp command\",\n            info=\"mcp command\",\n            value=\"uvx mcp-sse-shim@latest\",\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Tools\", name=\"tools\", method=\"build_output\"),\n    ]\n\n    async def build_output(self) -> list[Tool]:\n        if self.client.session is None:\n            self.tools = await self.client.connect_to_server(self.command)\n\n        tool_list = []\n\n        for tool in self.tools:\n            args_schema = create_input_schema_from_json_schema(tool.inputSchema)\n            tool_list.append(\n                Tool(\n                    name=tool.name,\n                    description=tool.description,\n                    coroutine=create_tool_coroutine(tool.name, args_schema, self.client.session),\n                    func=create_tool_func(tool.name, args_schema),\n                )\n            )\n        self.tool_names = [tool.name for tool in self.tools]\n        return tool_list\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "command": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "command",
                    "value": "uvx mcp-sse-shim@latest",
                    "display_name": "mcp command",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "mcp command",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                }
            },
            "description": "Connects to an MCP server over stdio and exposes it's tools as tools to be used by an Agent.",
            "icon": "code",
            "base_classes": [
                "Tool"
            ],
            "display_name": "MCP Tools (stdio)",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Tool"
                    ],
                    "selected": "Tool",
                    "name": "tools",
                    "display_name": "Tools",
                    "method": "build_output",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "command"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "PythonCodeStructuredTool": {
            "template": {
                "_type": "Component",
                "_classes": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "_classes",
                    "value": "",
                    "display_name": "Classes",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "_functions": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "_functions",
                    "value": "",
                    "display_name": "Functions",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "import ast\nimport json\nfrom typing import Any\n\nfrom langchain.agents import Tool\nfrom langchain_core.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic.v1 import Field, create_model\nfrom pydantic.v1.fields import Undefined\nfrom typing_extensions import override\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.inputs.inputs import (\n    BoolInput,\n    DropdownInput,\n    FieldTypes,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n)\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\n\nclass PythonCodeStructuredTool(LCToolComponent):\n    DEFAULT_KEYS = [\n        \"code\",\n        \"_type\",\n        \"text_key\",\n        \"tool_code\",\n        \"tool_name\",\n        \"tool_description\",\n        \"return_direct\",\n        \"tool_function\",\n        \"global_variables\",\n        \"_classes\",\n        \"_functions\",\n    ]\n    display_name = \"Python Code Structured\"\n    description = \"structuredtool dataclass code to tool\"\n    documentation = \"https://python.langchain.com/docs/modules/tools/custom_tools/#structuredtool-dataclass\"\n    name = \"PythonCodeStructuredTool\"\n    icon = \"Python\"\n    field_order = [\"name\", \"description\", \"tool_code\", \"return_direct\", \"tool_function\"]\n    legacy: bool = True\n\n    inputs = [\n        MultilineInput(\n            name=\"tool_code\",\n            display_name=\"Tool Code\",\n            info=\"Enter the dataclass code.\",\n            placeholder=\"def my_function(args):\\n    pass\",\n            required=True,\n            real_time_refresh=True,\n            refresh_button=True,\n        ),\n        MessageTextInput(\n            name=\"tool_name\",\n            display_name=\"Tool Name\",\n            info=\"Enter the name of the tool.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"tool_description\",\n            display_name=\"Description\",\n            info=\"Enter the description of the tool.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"return_direct\",\n            display_name=\"Return Directly\",\n            info=\"Should the tool return the function output directly?\",\n        ),\n        DropdownInput(\n            name=\"tool_function\",\n            display_name=\"Tool Function\",\n            info=\"Select the function for additional expressions.\",\n            options=[],\n            required=True,\n            real_time_refresh=True,\n            refresh_button=True,\n        ),\n        HandleInput(\n            name=\"global_variables\",\n            display_name=\"Global Variables\",\n            info=\"Enter the global variables or Create Data Component.\",\n            input_types=[\"Data\"],\n            field_type=FieldTypes.DICT,\n            is_list=True,\n        ),\n        MessageTextInput(name=\"_classes\", display_name=\"Classes\", advanced=True),\n        MessageTextInput(name=\"_functions\", display_name=\"Functions\", advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Tool\", name=\"result_tool\", method=\"build_tool\"),\n    ]\n\n    @override\n    async def update_build_config(\n        self, build_config: dotdict, field_value: Any, field_name: str | None = None\n    ) -> dotdict:\n        if field_name is None:\n            return build_config\n\n        if field_name not in {\"tool_code\", \"tool_function\"}:\n            return build_config\n\n        try:\n            named_functions = {}\n            [classes, functions] = self._parse_code(build_config[\"tool_code\"][\"value\"])\n            existing_fields = {}\n            if len(build_config) > len(self.DEFAULT_KEYS):\n                for key in build_config.copy():\n                    if key not in self.DEFAULT_KEYS:\n                        existing_fields[key] = build_config.pop(key)\n\n            names = []\n            for func in functions:\n                named_functions[func[\"name\"]] = func\n                names.append(func[\"name\"])\n\n                for arg in func[\"args\"]:\n                    field_name = f\"{func['name']}|{arg['name']}\"\n                    if field_name in existing_fields:\n                        build_config[field_name] = existing_fields[field_name]\n                        continue\n\n                    field = MessageTextInput(\n                        display_name=f\"{arg['name']}: Description\",\n                        name=field_name,\n                        info=f\"Enter the description for {arg['name']}\",\n                        required=True,\n                    )\n                    build_config[field_name] = field.to_dict()\n            build_config[\"_functions\"][\"value\"] = json.dumps(named_functions)\n            build_config[\"_classes\"][\"value\"] = json.dumps(classes)\n            build_config[\"tool_function\"][\"options\"] = names\n        except Exception as e:  # noqa: BLE001\n            self.status = f\"Failed to extract names: {e}\"\n            logger.opt(exception=True).debug(self.status)\n            build_config[\"tool_function\"][\"options\"] = [\"Failed to parse\", str(e)]\n        return build_config\n\n    async def build_tool(self) -> Tool:\n        local_namespace = {}  # type: ignore[var-annotated]\n        modules = self._find_imports(self.tool_code)\n        import_code = \"\"\n        for module in modules[\"imports\"]:\n            import_code += f\"global {module}\\nimport {module}\\n\"\n        for from_module in modules[\"from_imports\"]:\n            for alias in from_module.names:\n                import_code += f\"global {alias.name}\\n\"\n            import_code += (\n                f\"from {from_module.module} import {', '.join([alias.name for alias in from_module.names])}\\n\"\n            )\n        exec(import_code, globals())\n        exec(self.tool_code, globals(), local_namespace)\n\n        class PythonCodeToolFunc:\n            params: dict = {}\n\n            def run(**kwargs):\n                for key, arg in kwargs.items():\n                    if key not in PythonCodeToolFunc.params:\n                        PythonCodeToolFunc.params[key] = arg\n                return local_namespace[self.tool_function](**PythonCodeToolFunc.params)\n\n        globals_ = globals()\n        local = {}\n        local[self.tool_function] = PythonCodeToolFunc\n        globals_.update(local)\n\n        if isinstance(self.global_variables, list):\n            for data in self.global_variables:\n                if isinstance(data, Data):\n                    globals_.update(data.data)\n        elif isinstance(self.global_variables, dict):\n            globals_.update(self.global_variables)\n\n        classes = json.loads(self._attributes[\"_classes\"])\n        for class_dict in classes:\n            exec(\"\\n\".join(class_dict[\"code\"]), globals_)\n\n        named_functions = json.loads(self._attributes[\"_functions\"])\n        schema_fields = {}\n\n        for attr in self._attributes:\n            if attr in self.DEFAULT_KEYS:\n                continue\n\n            func_name = attr.split(\"|\")[0]\n            field_name = attr.split(\"|\")[1]\n            func_arg = self._find_arg(named_functions, func_name, field_name)\n            if func_arg is None:\n                msg = f\"Failed to find arg: {field_name}\"\n                raise ValueError(msg)\n\n            field_annotation = func_arg[\"annotation\"]\n            field_description = self._get_value(self._attributes[attr], str)\n\n            if field_annotation:\n                exec(f\"temp_annotation_type = {field_annotation}\", globals_)\n                schema_annotation = globals_[\"temp_annotation_type\"]\n            else:\n                schema_annotation = Any\n            schema_fields[field_name] = (\n                schema_annotation,\n                Field(\n                    default=func_arg.get(\"default\", Undefined),\n                    description=field_description,\n                ),\n            )\n\n        if \"temp_annotation_type\" in globals_:\n            globals_.pop(\"temp_annotation_type\")\n\n        python_code_tool_schema = None\n        if schema_fields:\n            python_code_tool_schema = create_model(\"PythonCodeToolSchema\", **schema_fields)\n\n        return StructuredTool.from_function(\n            func=local[self.tool_function].run,\n            args_schema=python_code_tool_schema,\n            name=self.tool_name,\n            description=self.tool_description,\n            return_direct=self.return_direct,\n        )\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        frontend_node[\"template\"] = await self.update_build_config(\n            frontend_node[\"template\"],\n            frontend_node[\"template\"][\"tool_code\"][\"value\"],\n            \"tool_code\",\n        )\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        for key in frontend_node[\"template\"]:\n            if key in self.DEFAULT_KEYS:\n                continue\n            frontend_node[\"template\"] = await self.update_build_config(\n                frontend_node[\"template\"], frontend_node[\"template\"][key][\"value\"], key\n            )\n            frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        return frontend_node\n\n    def _parse_code(self, code: str) -> tuple[list[dict], list[dict]]:\n        parsed_code = ast.parse(code)\n        lines = code.split(\"\\n\")\n        classes = []\n        functions = []\n        for node in parsed_code.body:\n            if isinstance(node, ast.ClassDef):\n                class_lines = lines[node.lineno - 1 : node.end_lineno]\n                class_lines[-1] = class_lines[-1][: node.end_col_offset]\n                class_lines[0] = class_lines[0][node.col_offset :]\n                classes.append(\n                    {\n                        \"name\": node.name,\n                        \"code\": class_lines,\n                    }\n                )\n                continue\n\n            if not isinstance(node, ast.FunctionDef):\n                continue\n\n            func = {\"name\": node.name, \"args\": []}\n            for arg in node.args.args:\n                if arg.lineno != arg.end_lineno:\n                    msg = \"Multiline arguments are not supported\"\n                    raise ValueError(msg)\n\n                func_arg = {\n                    \"name\": arg.arg,\n                    \"annotation\": None,\n                }\n\n                for default in node.args.defaults:\n                    if (\n                        arg.lineno > default.lineno\n                        or arg.col_offset > default.col_offset\n                        or (\n                            arg.end_lineno is not None\n                            and default.end_lineno is not None\n                            and arg.end_lineno < default.end_lineno\n                        )\n                        or (\n                            arg.end_col_offset is not None\n                            and default.end_col_offset is not None\n                            and arg.end_col_offset < default.end_col_offset\n                        )\n                    ):\n                        continue\n\n                    if isinstance(default, ast.Name):\n                        func_arg[\"default\"] = default.id\n                    elif isinstance(default, ast.Constant):\n                        func_arg[\"default\"] = default.value\n\n                if arg.annotation:\n                    annotation_line = lines[arg.annotation.lineno - 1]\n                    annotation_line = annotation_line[: arg.annotation.end_col_offset]\n                    annotation_line = annotation_line[arg.annotation.col_offset :]\n                    func_arg[\"annotation\"] = annotation_line\n                    if isinstance(func_arg[\"annotation\"], str) and func_arg[\"annotation\"].count(\"=\") > 0:\n                        func_arg[\"annotation\"] = \"=\".join(func_arg[\"annotation\"].split(\"=\")[:-1]).strip()\n                if isinstance(func[\"args\"], list):\n                    func[\"args\"].append(func_arg)\n            functions.append(func)\n\n        return classes, functions\n\n    def _find_imports(self, code: str) -> dotdict:\n        imports: list[str] = []\n        from_imports = []\n        parsed_code = ast.parse(code)\n        for node in parsed_code.body:\n            if isinstance(node, ast.Import):\n                imports.extend(alias.name for alias in node.names)\n            elif isinstance(node, ast.ImportFrom):\n                from_imports.append(node)\n        return dotdict({\"imports\": imports, \"from_imports\": from_imports})\n\n    def _get_value(self, value: Any, annotation: Any) -> Any:\n        return value if isinstance(value, annotation) else value[\"value\"]\n\n    def _find_arg(self, named_functions: dict, func_name: str, arg_name: str) -> dict | None:\n        for arg in named_functions[func_name][\"args\"]:\n            if arg[\"name\"] == arg_name:\n                return arg\n        return None\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "global_variables": {
                    "trace_as_metadata": true,
                    "list": true,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "global_variables",
                    "value": "",
                    "display_name": "Global Variables",
                    "advanced": false,
                    "input_types": [
                        "Data"
                    ],
                    "dynamic": false,
                    "info": "Enter the global variables or Create Data Component.",
                    "title_case": false,
                    "type": "dict",
                    "_input_type": "HandleInput"
                },
                "return_direct": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "return_direct",
                    "value": false,
                    "display_name": "Return Directly",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Should the tool return the function output directly?",
                    "title_case": false,
                    "type": "bool",
                    "_input_type": "BoolInput"
                },
                "tool_code": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "def my_function(args):\n    pass",
                    "show": true,
                    "name": "tool_code",
                    "value": "",
                    "display_name": "Tool Code",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Enter the dataclass code.",
                    "real_time_refresh": true,
                    "refresh_button": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                },
                "tool_description": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "tool_description",
                    "value": "",
                    "display_name": "Description",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Enter the description of the tool.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "tool_function": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "options": [],
                    "options_metadata": [],
                    "combobox": false,
                    "dialog_inputs": {},
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "tool_function",
                    "value": "",
                    "display_name": "Tool Function",
                    "advanced": false,
                    "dynamic": false,
                    "info": "Select the function for additional expressions.",
                    "real_time_refresh": true,
                    "refresh_button": true,
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "tool_name": {
                    "tool_mode": false,
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "tool_name",
                    "value": "",
                    "display_name": "Tool Name",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Enter the name of the tool.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                }
            },
            "description": "structuredtool dataclass code to tool",
            "icon": "Python",
            "base_classes": [
                "Tool"
            ],
            "display_name": "Python Code Structured",
            "documentation": "https://python.langchain.com/docs/modules/tools/custom_tools/#structuredtool-dataclass",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Tool"
                    ],
                    "selected": "Tool",
                    "name": "result_tool",
                    "display_name": "Tool",
                    "method": "build_tool",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "tool_code",
                "tool_name",
                "tool_description",
                "return_direct",
                "tool_function",
                "global_variables",
                "_classes",
                "_functions"
            ],
            "beta": false,
            "legacy": true,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "PythonREPLTool": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "import importlib\n\nfrom langchain.tools import StructuredTool\nfrom langchain_core.tools import ToolException\nfrom langchain_experimental.utilities import PythonREPL\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import StrInput\nfrom langflow.schema import Data\n\n\nclass PythonREPLToolComponent(LCToolComponent):\n    display_name = \"Python REPL [DEPRECATED]\"\n    description = \"A tool for running Python code in a REPL environment.\"\n    name = \"PythonREPLTool\"\n    icon = \"Python\"\n    legacy = True\n\n    inputs = [\n        StrInput(\n            name=\"name\",\n            display_name=\"Tool Name\",\n            info=\"The name of the tool.\",\n            value=\"python_repl\",\n        ),\n        StrInput(\n            name=\"description\",\n            display_name=\"Tool Description\",\n            info=\"A description of the tool.\",\n            value=\"A Python shell. Use this to execute python commands. \"\n            \"Input should be a valid python command. \"\n            \"If you want to see the output of a value, you should print it out with `print(...)`.\",\n        ),\n        StrInput(\n            name=\"global_imports\",\n            display_name=\"Global Imports\",\n            info=\"A comma-separated list of modules to import globally, e.g. 'math,numpy'.\",\n            value=\"math\",\n        ),\n        StrInput(\n            name=\"code\",\n            display_name=\"Python Code\",\n            info=\"The Python code to execute.\",\n            value=\"print('Hello, World!')\",\n        ),\n    ]\n\n    class PythonREPLSchema(BaseModel):\n        code: str = Field(..., description=\"The Python code to execute.\")\n\n    def get_globals(self, global_imports: str | list[str]) -> dict:\n        global_dict = {}\n        if isinstance(global_imports, str):\n            modules = [module.strip() for module in global_imports.split(\",\")]\n        elif isinstance(global_imports, list):\n            modules = global_imports\n        else:\n            msg = \"global_imports must be either a string or a list\"\n            raise TypeError(msg)\n\n        for module in modules:\n            try:\n                imported_module = importlib.import_module(module)\n                global_dict[imported_module.__name__] = imported_module\n            except ImportError as e:\n                msg = f\"Could not import module {module}\"\n                raise ImportError(msg) from e\n        return global_dict\n\n    def build_tool(self) -> Tool:\n        globals_ = self.get_globals(self.global_imports)\n        python_repl = PythonREPL(_globals=globals_)\n\n        def run_python_code(code: str) -> str:\n            try:\n                return python_repl.run(code)\n            except Exception as e:\n                logger.opt(exception=True).debug(\"Error running Python code\")\n                raise ToolException(str(e)) from e\n\n        tool = StructuredTool.from_function(\n            name=self.name,\n            description=self.description,\n            func=run_python_code,\n            args_schema=self.PythonREPLSchema,\n        )\n\n        self.status = f\"Python REPL Tool created with global imports: {self.global_imports}\"\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n        result = tool.run(self.code)\n        return [Data(data={\"result\": result})]\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "description": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "description",
                    "value": "A Python shell. Use this to execute python commands. Input should be a valid python command. If you want to see the output of a value, you should print it out with `print(...)`.",
                    "display_name": "Tool Description",
                    "advanced": false,
                    "dynamic": false,
                    "info": "A description of the tool.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "global_imports": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "global_imports",
                    "value": "math",
                    "display_name": "Global Imports",
                    "advanced": false,
                    "dynamic": false,
                    "info": "A comma-separated list of modules to import globally, e.g. 'math,numpy'.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "name": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "name",
                    "value": "python_repl",
                    "display_name": "Tool Name",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The name of the tool.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                }
            },
            "description": "A tool for running Python code in a REPL environment.",
            "icon": "Python",
            "base_classes": [
                "Data",
                "Tool"
            ],
            "display_name": "Python REPL [DEPRECATED]",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "api_run_model",
                    "display_name": "Data",
                    "method": "run_model",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": true
                },
                {
                    "types": [
                        "Tool"
                    ],
                    "selected": "Tool",
                    "name": "api_build_tool",
                    "display_name": "Tool",
                    "method": "build_tool",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "required_inputs": [],
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "name",
                "description",
                "global_imports",
                "code"
            ],
            "beta": false,
            "legacy": true,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        },
        "PythonREPLComponent": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "import importlib\n\nfrom langchain_experimental.utilities import PythonREPL\n\nfrom langflow.custom import Component\nfrom langflow.io import CodeInput, Output, StrInput\nfrom langflow.schema import Data\n\n\nclass PythonREPLComponent(Component):\n    display_name = \"Python REPL\"\n    description = (\n        \"A Python code executor that lets you run Python code with specific imported modules. \"\n        \"Remember to always use print() to see your results. Example: print(df.head())\"\n    )\n    icon = \"Python\"\n\n    inputs = [\n        StrInput(\n            name=\"global_imports\",\n            display_name=\"Global Imports\",\n            info=\"A comma-separated list of modules to import globally, e.g. 'math,numpy,pandas'.\",\n            value=\"math,pandas\",\n            required=True,\n        ),\n        CodeInput(\n            name=\"python_code\",\n            display_name=\"Python Code\",\n            info=\"The Python code to execute. Only modules specified in Global Imports can be used.\",\n            value=\"print('Hello, World!')\",\n            tool_mode=True,\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Results\",\n            name=\"results\",\n            type_=Data,\n            method=\"run_python_repl\",\n        ),\n    ]\n\n    def get_globals(self, global_imports: str | list[str]) -> dict:\n        \"\"\"Create a globals dictionary with only the specified allowed imports.\"\"\"\n        global_dict = {}\n\n        try:\n            if isinstance(global_imports, str):\n                modules = [module.strip() for module in global_imports.split(\",\")]\n            elif isinstance(global_imports, list):\n                modules = global_imports\n            else:\n                msg = \"global_imports must be either a string or a list\"\n                raise TypeError(msg)\n\n            for module in modules:\n                try:\n                    imported_module = importlib.import_module(module)\n                    global_dict[imported_module.__name__] = imported_module\n                except ImportError as e:\n                    msg = f\"Could not import module {module}: {e!s}\"\n                    raise ImportError(msg) from e\n\n        except Exception as e:\n            self.log(f\"Error in global imports: {e!s}\")\n            raise\n        else:\n            self.log(f\"Successfully imported modules: {list(global_dict.keys())}\")\n            return global_dict\n\n    def run_python_repl(self) -> Data:\n        try:\n            globals_ = self.get_globals(self.global_imports)\n            python_repl = PythonREPL(_globals=globals_)\n            result = python_repl.run(self.python_code)\n            result = result.strip() if result else \"\"\n\n            self.log(\"Code execution completed successfully\")\n            return Data(data={\"result\": result})\n\n        except ImportError as e:\n            error_message = f\"Import Error: {e!s}\"\n            self.log(error_message)\n            return Data(data={\"error\": error_message})\n\n        except SyntaxError as e:\n            error_message = f\"Syntax Error: {e!s}\"\n            self.log(error_message)\n            return Data(data={\"error\": error_message})\n\n        except (NameError, TypeError, ValueError) as e:\n            error_message = f\"Error during execution: {e!s}\"\n            self.log(error_message)\n            return Data(data={\"error\": error_message})\n\n    def build(self):\n        return self.run_python_repl\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "global_imports": {
                    "tool_mode": false,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "global_imports",
                    "value": "math,pandas",
                    "display_name": "Global Imports",
                    "advanced": false,
                    "dynamic": false,
                    "info": "A comma-separated list of modules to import globally, e.g. 'math,numpy,pandas'.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "StrInput"
                },
                "python_code": {
                    "tool_mode": true,
                    "trace_as_input": true,
                    "list": false,
                    "list_add_label": "Add More",
                    "required": true,
                    "placeholder": "",
                    "show": true,
                    "name": "python_code",
                    "value": "print('Hello, World!')",
                    "display_name": "Python Code",
                    "advanced": false,
                    "dynamic": false,
                    "info": "The Python code to execute. Only modules specified in Global Imports can be used.",
                    "title_case": false,
                    "type": "code",
                    "_input_type": "CodeInput"
                }
            },
            "description": "A Python code executor that lets you run Python code with specific imported modules. Remember to always use print() to see your results. Example: print(df.head())",
            "icon": "Python",
            "base_classes": [
                "Data"
            ],
            "display_name": "Python REPL",
            "documentation": "",
            "minimized": false,
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "results",
                    "display_name": "Results",
                    "method": "run_python_repl",
                    "value": "__UNDEFINED__",
                    "cache": true,
                    "allows_loop": false,
                    "tool_mode": true
                }
            ],
            "field_order": [
                "global_imports",
                "python_code"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
        }
    }
} as const;